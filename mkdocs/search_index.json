{
    "docs": [
        {
            "location": "/", 
            "text": "buff-em\n documentation: Table of contents\n\n \n\n\n\n\nGeneral reference\n\n\n\n\nTop-level overview\n\n\nInstallation\n\n\nGeometry files\n\n\nSVTensor files\n\n\nKey differences between \nbuff-em\n and \nscuff-em\n\n\n\n\n\n\nTutorial examples\n\n\n\n\nMie scattering\n\n\nPower, force, and torque on Janus particles irradiated by plane waves\n\n\nThermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nThermal radiation and self-propulsion of photon torpedoes\n\n\nThermal self-rotation of QED pinwheels\n\n\n\n\nCommand-line application reference\n\n\nNanophotonics code\n\n\n\n\nbuff-scatter\n    - general-purpose electromagnetic scattering\n\n\n\n\nNon-equilibrium Casimir/ heat-transfer code\n\n\n\n\nbuff-neq\n            - radiative heat transfer and non-equilibrium Casimir forces/torques\n\n\n\n\nUtility code\n\n\n\n\nbuff-analyze\n    - diagnostic tool to print info on \nbuff-em\n geometries\n\n\n\n\nAPI reference\n\n\n\n\nlibbuff\n - Accessing \nbuff-em\n from C++ programs\n\n\n\n\nTechnical memo\n\n\n\n\nbuff-em\n technical memo", 
            "title": "BUFF-EM documentation"
        }, 
        {
            "location": "/#tutorial-examples", 
            "text": "Mie scattering  Power, force, and torque on Janus particles irradiated by plane waves  Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres  Thermal radiation and self-propulsion of photon torpedoes  Thermal self-rotation of QED pinwheels", 
            "title": "Tutorial examples"
        }, 
        {
            "location": "/#command-line-application-reference", 
            "text": "Nanophotonics code   buff-scatter     - general-purpose electromagnetic scattering   Non-equilibrium Casimir/ heat-transfer code   buff-neq             - radiative heat transfer and non-equilibrium Casimir forces/torques   Utility code   buff-analyze     - diagnostic tool to print info on  buff-em  geometries", 
            "title": "Command-line application reference"
        }, 
        {
            "location": "/#api-reference", 
            "text": "libbuff  - Accessing  buff-em  from C++ programs", 
            "title": "API reference"
        }, 
        {
            "location": "/#technical-memo", 
            "text": "buff-em  technical memo", 
            "title": "Technical memo"
        }, 
        {
            "location": "/examples/MieScattering/", 
            "text": "Mie scattering in \nbuff-em\n\n\nIn this example we use \nbuff-scatter\n to solve the canonical textbook\nproblem of \nMie scattering\n---the scattering of a plane wave\nfrom a dielectric sphere. The files for this example are in the \n\nshare/buff-em/examples/MieScattering\n subdirectory of the \n\nbuff-em\n source distribution.\n\n\n\n\ngmsh\n geometry file and volume mesh for a single sphere\n\n\nWe begin by creating a \n\ngmsh\n \ngeometry file for a sphere: \n(\nSphere.geo\n)\n.\n(Note that, because we will be producing a volume mesh instead \nof a surface mesh, the \ngmsh\n geometry file is not quite\nthe same as the file \nSphere.geo\n that we used to \ngenerate surface meshes for \n\nMie scattering in \nscuff-em\n.\n\n\nWe turn this geometry file into coarser and finer \nvolume meshes by running the following commands:\n\n\n % gmsh -3 -clscale 1.0  Sphere.geo\n % RenameMesh3D Sphere.msh\n\n % gmsh -3 -clscale 0.65 Sphere.geo\n % RenameMesh3D Sphere.msh\n\n\n\n\nHere the \n-3\n option to \ngmsh\n says we want a 3D (volume) mesh \n(as opposed to \n-2\n for a 2D (surface) mesh. The \n-clscale\n\noption sets an overall multiplicative prefactor that scales\nthe fineness of the meshing.\n\n\nAlso, the \nbash\n script \nRenameMesh3D\n\nis a little utility that calls \n\nbuff-analyze\n\nto count the number of interior tetrahedon faces in the mesh \n(equal to the number of SWG basis functions, and thus\nthe dimension of the VIE matrix) and rename the meshfile to\nreflect this information. The script also changes the file \nextension from \n.msh\n to \n.vmsh\n to remind me that this is a \nvolume mesh instead of a surface mesh.\n\n\nThus the above steps produce files named \n\nSphere_677.vmsh\n and \nSphere_1675.vmsh\n. \nYou can open these files in \ngmsh\n to see what they\nlook like:\n\n\n\n\n\n\nOf course, from these pictures we can't tell that we \nare working with volume meshes instead of surface meshes.\nTo see the outlines of the tetrahedra, turn off the \n\"Surface faces\" display in the \ngmsh\n \"Mesh\" options \ntab:\n\n\n\n\n\n\nbuff-em\n geometry file for a single sphere\n\n\nNext we create a \n\nbuff-em\n geometry file\n \nthat will tell \nbuff-scatter\n about our geometry, including both \nthe volume mesh and the material properties (dielectric function) \nof the sphere. As a first example, we'll use a dielectric model for\nsilicon carbide that expresses the relative permittivity as a\nrational function of \n\\omega\n; in this case we'll call the\ngeometry file \nSiCSphere_677.buffgeo.\n\n\nMATERIAL SiliconCarbide\n\n   EpsInf = 6.7;\n   a0     = -3.32377e28;\n   a1     = +8.93329e11;\n   b0     = -2.21677e28;\n   b1     = 8.93329e11;\n   Eps(w) = EpsInf * (a0 + i*a1*w + w*w) / ( b0 + i*b1*w + w*w);\n\nENDMATERIAL \n\nOBJECT TheSphere\n        MESHFILE Sphere_677.vmsh\n        MATERIAL SiliconCarbide\nENDOBJECT\n\n\n\n\n(Note that, because this particular example involves an isotropic\nand homogeneous (spatially constant) dielectric function, we\ncan simply use the \nMATERIAL\n keyword to specify a \n\nscuff-em\n material property definition\n,\njust as we would in a \nscuff-em\n geometry file. To specify\nanisotropic and/or inhomogeneous materials in \nbuff-em\n, \nwe would instead use the \nSVTensor\n keyword, as documented on \nthe page \n\nSpatially-varying permittivity tensors in \nbuff-em\n.\nWe will see an example of a \nSVTensor\n specification later\nin this tutorial example.)\n\n\n\n\nDefining frequencies at which to run computations\n\n\nNext, we create a simple file called\n\nOmegaFile\n containing a\nlist of angular frequencies at which to run the scattering problem:\n\n\n    0.010\n    0.013\n    ...\n    10.0\n\n\n\n\n(We pause to note one subtlety here: As in \nscuff-em\n,\nangular frequencies specified\nusing the \n--Omega\n or \n--OmegaFile\n arguments are interpreted in \nunits of \nc / 1 \\mu\nm = \n3\\cdot 10^{14}\n rad/sec.\nThese are natural \nfrequency units to use for problems involving micron-sized objects; \nin particular, for Mie scattering from a sphere of radius 1 \u03bcm, as \nwe are considering here, the numerical value of \nOmega\n is just the \nquantity \nkR\n (wavenumber times radius) known as the \n\"size parameter\" in the Mie scattering literature. In contrast, \nwhen specifying functions of angular frequency like \nEps(w)\n in \n\nMATERIAL...ENDMATERIAL\n sections of geometry files or in any other \n\nbuff-em\n material description\n, \nthe \nw\n variable \nis always interpreted in units of \n1 \nrad/sec\n, because these are\nthe units in which tabulated material properties and functional forms\nfor model dielectric functions are typically expressed.)\n\n\n\n\nRunning the sphere computation\n\n\nFinally, we'll create a little text file called \nArgs\n that will contain\na list of command-line options for \nbuff-scatter\n; these will include\n\n(1)\n a specification of the geometry, \n(2)\n the frequency list,\n\n(3)\n the name of an output file for the power, force, and torque,\nand \n(4)\n a specification of the incident field, which in\nthis case is a linearly polarized \nz\n-traveling plane wave\nwith \nE\n-field pointing in the \nx\n direction:\n\n\n    geometry SiCSphere_677.buffgeo\n    PFTFile SiCSphere.PFT\n    OmegaFile OmegaFile\n    pwDirection 0 0 1\n    pwPolarization 1 0 0\n\n\n\n\nAnd now we just pipe this little file into the standard input of \nbuff-scatter\n:\n\n\n    % buff-scatter \n Args \n\n\n\n\nThis produces the file \nSiCSphere_677.PFT\n, which contains one line\nper simulated frequency; each line contains data on the scattered\nand total power, the force, and the torque on the particle at that\nfrequency. (Look at the first few lines of the file for a text description\nof how to interpret it.)\n\n\nHere's a comparison of the \nbuff-scatter\n results with the\nanalytical Mie series, as computed\nusing \nthis Mathematica script.\n [Like most Mie codes, \nthis script computes the absorption and scattering \ncross-sections\n, \nwhich we multiply by the incoming beam flux (\n\\frac{1}{2Z_0}\n for a \nunit-strength plane wave in vacuum) to get values for the absorbed \nand scattered \npower\n.]\n\n\n\n\n\n\nA note on computation time\n\n\nAs discussed \nhere\n, the first \ncalculation done by \nbuff-em\n on any given geometry\nwill be significantly slower than all subsequent \ncalculations (including the 2nd and subsequent\nfrequencies in the \nOmegaFile\n, as well as any \nsubsequent \nbuff-scatter\n or \nbuff-neq\n\nruns you may do using the same object mesh, even\nif you change the material properties). The reason\nfor this is that, when \nbuff-em\n first assembles\nthe self-interaction block of the system matrix for \na given object, it stores the most time-intensive \nportions of the calculation for later reuse.\n(The data are stored in memory for reuse within the\nsame run, and are also written to disk in the form of \na binary cache file for reuse in later runs).\n\n\nFor the particular calculation described here,\nyou can accelerate this process by downloading the\n(13 megabyte) cache file for the \nSphere_677.vmsh\n\nfrom this link: \n\nSphere_677.cache\n.\nPut this file into your working directory when you\nrun \nbuff-scatter\n, and the calculation\nwill proceed much more quickly. \n\n\nFor example, on my (fairly fast) laptop, computing\nthe cache file takes 12 minutes, after which computing\nthe PFT at each individual frequency takes about 20 seconds.\n\n\nYou can monitor the progress of the calculation by following \nthe \nbuff-scatter.log\n file. Note that, during\ncomputationally-intensive operations such as the VIE matrix\nassembly, the code should be using all available CPU cores\non your workstation; if you find that this is\nnot the case (for example, by monitoring CPU usage using\n\nhtop\n)\nyou may need to\n\nreconfigure and recompile with different \nopenmp\n \nconfiguration options.", 
            "title": "Mie scattering"
        }, 
        {
            "location": "/examples/MieScattering/#gmsh-geometry-file-and-volume-mesh-for-a-single-sphere", 
            "text": "We begin by creating a  gmsh  \ngeometry file for a sphere:  ( Sphere.geo ) .\n(Note that, because we will be producing a volume mesh instead \nof a surface mesh, the  gmsh  geometry file is not quite\nthe same as the file  Sphere.geo  that we used to \ngenerate surface meshes for  Mie scattering in  scuff-em .  We turn this geometry file into coarser and finer \nvolume meshes by running the following commands:   % gmsh -3 -clscale 1.0  Sphere.geo\n % RenameMesh3D Sphere.msh\n\n % gmsh -3 -clscale 0.65 Sphere.geo\n % RenameMesh3D Sphere.msh  Here the  -3  option to  gmsh  says we want a 3D (volume) mesh \n(as opposed to  -2  for a 2D (surface) mesh. The  -clscale \noption sets an overall multiplicative prefactor that scales\nthe fineness of the meshing.  Also, the  bash  script  RenameMesh3D \nis a little utility that calls  buff-analyze \nto count the number of interior tetrahedon faces in the mesh \n(equal to the number of SWG basis functions, and thus\nthe dimension of the VIE matrix) and rename the meshfile to\nreflect this information. The script also changes the file \nextension from  .msh  to  .vmsh  to remind me that this is a \nvolume mesh instead of a surface mesh.  Thus the above steps produce files named  Sphere_677.vmsh  and  Sphere_1675.vmsh . \nYou can open these files in  gmsh  to see what they\nlook like:    Of course, from these pictures we can't tell that we \nare working with volume meshes instead of surface meshes.\nTo see the outlines of the tetrahedra, turn off the \n\"Surface faces\" display in the  gmsh  \"Mesh\" options \ntab:", 
            "title": "gmsh geometry file and volume mesh for a single sphere"
        }, 
        {
            "location": "/examples/MieScattering/#buff-em-geometry-file-for-a-single-sphere", 
            "text": "Next we create a  buff-em  geometry file  \nthat will tell  buff-scatter  about our geometry, including both \nthe volume mesh and the material properties (dielectric function) \nof the sphere. As a first example, we'll use a dielectric model for\nsilicon carbide that expresses the relative permittivity as a\nrational function of  \\omega ; in this case we'll call the\ngeometry file  SiCSphere_677.buffgeo.  MATERIAL SiliconCarbide\n\n   EpsInf = 6.7;\n   a0     = -3.32377e28;\n   a1     = +8.93329e11;\n   b0     = -2.21677e28;\n   b1     = 8.93329e11;\n   Eps(w) = EpsInf * (a0 + i*a1*w + w*w) / ( b0 + i*b1*w + w*w);\n\nENDMATERIAL \n\nOBJECT TheSphere\n        MESHFILE Sphere_677.vmsh\n        MATERIAL SiliconCarbide\nENDOBJECT  (Note that, because this particular example involves an isotropic\nand homogeneous (spatially constant) dielectric function, we\ncan simply use the  MATERIAL  keyword to specify a  scuff-em  material property definition ,\njust as we would in a  scuff-em  geometry file. To specify\nanisotropic and/or inhomogeneous materials in  buff-em , \nwe would instead use the  SVTensor  keyword, as documented on \nthe page  Spatially-varying permittivity tensors in  buff-em .\nWe will see an example of a  SVTensor  specification later\nin this tutorial example.)", 
            "title": "buff-em geometry file for a single sphere"
        }, 
        {
            "location": "/examples/MieScattering/#defining-frequencies-at-which-to-run-computations", 
            "text": "Next, we create a simple file called OmegaFile  containing a\nlist of angular frequencies at which to run the scattering problem:      0.010\n    0.013\n    ...\n    10.0  (We pause to note one subtlety here: As in  scuff-em ,\nangular frequencies specified\nusing the  --Omega  or  --OmegaFile  arguments are interpreted in \nunits of  c / 1 \\mu m =  3\\cdot 10^{14}  rad/sec.\nThese are natural \nfrequency units to use for problems involving micron-sized objects; \nin particular, for Mie scattering from a sphere of radius 1 \u03bcm, as \nwe are considering here, the numerical value of  Omega  is just the \nquantity  kR  (wavenumber times radius) known as the \n\"size parameter\" in the Mie scattering literature. In contrast, \nwhen specifying functions of angular frequency like  Eps(w)  in  MATERIAL...ENDMATERIAL  sections of geometry files or in any other  buff-em  material description , \nthe  w  variable \nis always interpreted in units of  1  rad/sec , because these are\nthe units in which tabulated material properties and functional forms\nfor model dielectric functions are typically expressed.)", 
            "title": "Defining frequencies at which to run computations"
        }, 
        {
            "location": "/examples/MieScattering/#running-the-sphere-computation", 
            "text": "Finally, we'll create a little text file called  Args  that will contain\na list of command-line options for  buff-scatter ; these will include (1)  a specification of the geometry,  (2)  the frequency list, (3)  the name of an output file for the power, force, and torque,\nand  (4)  a specification of the incident field, which in\nthis case is a linearly polarized  z -traveling plane wave\nwith  E -field pointing in the  x  direction:      geometry SiCSphere_677.buffgeo\n    PFTFile SiCSphere.PFT\n    OmegaFile OmegaFile\n    pwDirection 0 0 1\n    pwPolarization 1 0 0  And now we just pipe this little file into the standard input of  buff-scatter :      % buff-scatter   Args   This produces the file  SiCSphere_677.PFT , which contains one line\nper simulated frequency; each line contains data on the scattered\nand total power, the force, and the torque on the particle at that\nfrequency. (Look at the first few lines of the file for a text description\nof how to interpret it.)  Here's a comparison of the  buff-scatter  results with the\nanalytical Mie series, as computed\nusing  this Mathematica script.  [Like most Mie codes, \nthis script computes the absorption and scattering  cross-sections , \nwhich we multiply by the incoming beam flux ( \\frac{1}{2Z_0}  for a \nunit-strength plane wave in vacuum) to get values for the absorbed \nand scattered  power .]", 
            "title": "Running the sphere computation"
        }, 
        {
            "location": "/examples/MieScattering/#a-note-on-computation-time", 
            "text": "As discussed  here , the first \ncalculation done by  buff-em  on any given geometry\nwill be significantly slower than all subsequent \ncalculations (including the 2nd and subsequent\nfrequencies in the  OmegaFile , as well as any \nsubsequent  buff-scatter  or  buff-neq \nruns you may do using the same object mesh, even\nif you change the material properties). The reason\nfor this is that, when  buff-em  first assembles\nthe self-interaction block of the system matrix for \na given object, it stores the most time-intensive \nportions of the calculation for later reuse.\n(The data are stored in memory for reuse within the\nsame run, and are also written to disk in the form of \na binary cache file for reuse in later runs).  For the particular calculation described here,\nyou can accelerate this process by downloading the\n(13 megabyte) cache file for the  Sphere_677.vmsh \nfrom this link:  Sphere_677.cache .\nPut this file into your working directory when you\nrun  buff-scatter , and the calculation\nwill proceed much more quickly.   For example, on my (fairly fast) laptop, computing\nthe cache file takes 12 minutes, after which computing\nthe PFT at each individual frequency takes about 20 seconds.  You can monitor the progress of the calculation by following \nthe  buff-scatter.log  file. Note that, during\ncomputationally-intensive operations such as the VIE matrix\nassembly, the code should be using all available CPU cores\non your workstation; if you find that this is\nnot the case (for example, by monitoring CPU usage using htop )\nyou may need to reconfigure and recompile with different  openmp  \nconfiguration options.", 
            "title": "A note on computation time"
        }, 
        {
            "location": "/examples/JanusParticles/", 
            "text": "Power, force, and torque on a Janus particle irradiated by a plane waves", 
            "title": "Power, force, and torque on a Janus particle irradiated by a plane wave"
        }, 
        {
            "location": "/examples/SiO2Spheres/", 
            "text": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres\n\n\nIn this example, we use \nbuff-neq\n to reproduce the results\nof [this example from the \nscuff-neq\n documentation][scuffSIO2Spheres].\nWe will compute \n(1)\n the power radiated by a single SiO2 \nsphere, and \n(2)\n the heat transfer and non-equilibrium \nCasimir force between two SiO2 spheres.\n\n\nThe files for this example may be found in the \n\nshare/buff-em/examples/SiO2Spheres\n subdirectory\nof your \nbuff-em\n installation.\n\n\n\n\ngmsh\n geometry file and volume mesh for a single sphere\n\n\nThe \ngmsh\n geometry file \nSphere.geo\n\ndescribes a sphere of radius 1 micron. (This is the\nsame file used in \nthis example\n; \nas noted there, it is not the same \n.geo\n file that\nwas used in the\n[\nscuff-neq\n version of this calculation][scuffSIO2Spheres],\nbecause for \nbuff-em\n we need volume meshes instead of \nsurface meshes. This file may be meshed to create\ncoarse and fine volume meshes as follows:\n\n\n% gmsh -3 -clscale 1 Sphere.geo\n% RenameMesh3D Sphere.msh\n% gmsh -3 -clscale 0.75 Sphere.geo\n% RenameMesh3D Sphere.msh\n\n\n\n\n(Here \nRenameMesh3D\n is a simple \nbash\n script\nthat uses \n\nbuff-analyze\n.\nto count the number of interior faces in a volume mesh and rename \nthe mesh file accordingly; note that it also changes\nthe file extension from \n.msh\n to \n.vmsh\n, which I find\nconvenient for distinguishing volume mesh files from\nsurface mesh files. \n\n\nThis produces the files \nSphere_637.msh\n and \nSphere_1727.msh,\n\nwhich you can visualize by opening in \ngmsh\n::\n\n\n% gmsh Sphere_637.msh\n\n\n\n\n\n\n% gmsh Sphere_1727.msh\n\n\n\n\n\n\nNote: As you can see from the first image here,\nby default \ngmsh\n\n\n\n\nbuff-em\n geometry files\n\n\nThe\n\nbuff-em\n geometry file\n\n\nSiO2Sphere_637.buffgeo\n\ndescribes a single SiO2 sphere.\n\n\nThe \nbuff-em\n geometry files\n\nSiO2Spheres_637.buffgeo\n\nand\n\nSiO2Spheres_1727.buffgeo\n\neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.\n\n\n% buff-analyze --geometry SiO2Spheres_1727.buffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1727.pp\n\n\n\n\n\n\n\n\nSpectral density of radiated power\n\n\nAs described in the \n\nbuff-neq\n documentation\n,\n\nbuff-neq\n computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies\n\n\\omega,\n in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux \n\\Phi.\n \nTo calculate this radiated-power flux at a given set\nof frequencies, we say\n\n\n % buff-neq --geometry SiO2Sphere_637.buffgeo --OmegaFile --PRad\n\n\n\n\nwhere \nOmegaFile\n is a list of\nangular frequencies. (Here \n--PRad\n says that we\nare interested in the radiated power).\nThis produces the file\n\nSiO2Sphere_637.SiFlux\n, which looks something\nlike this:\n\n\n# buff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04 \n\n\n\n\nAs the file header says, the second column here\nis the angular frequency \nin units of \n\\omega_0=3\\cdot 10^{14}\n rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the\n\ngeometrical transformation\n;\nsince \nwe didn't specify the \n--transfile\n option to \n\nbuff-neq\n, we have just a single geometric\nconfiguration, labeled \nDEFAULT\n. The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads\n\n11\n.)\n\n\nHere's a plot of the data:\n\n\n\n\nIn this plot, the solid line is the prediction of \nthe \nKrueger formalism\n, as computed\nby a \njulia\n code called \nKruegerFormulas.jl\n.\n\n\nThe plot is produced by \ngnuplot\n using \n\nthis script\n.\n\n\n\n\nSpectral density of power transfer and non-equilibrium force\n\n\nHere's a \nbash script\n that runs \nbuff-neq\n\nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files \nSiO2Spheres_637.SIFlux\n\nand \nSiO2Spheres_1727.SIFlux.\n Here are plots (produced\nby the same \ngnuplot\n script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the \njulia\n\ncode referenced above).", 
            "title": "Thermal radiation, heat transfer, and non-equilibrium Casimir forces between silicon dioxide spheres"
        }, 
        {
            "location": "/examples/SiO2Spheres/#gmsh-geometry-file-and-volume-mesh-for-a-single-sphere", 
            "text": "The  gmsh  geometry file  Sphere.geo \ndescribes a sphere of radius 1 micron. (This is the\nsame file used in  this example ; \nas noted there, it is not the same  .geo  file that\nwas used in the\n[ scuff-neq  version of this calculation][scuffSIO2Spheres],\nbecause for  buff-em  we need volume meshes instead of \nsurface meshes. This file may be meshed to create\ncoarse and fine volume meshes as follows:  % gmsh -3 -clscale 1 Sphere.geo\n% RenameMesh3D Sphere.msh\n% gmsh -3 -clscale 0.75 Sphere.geo\n% RenameMesh3D Sphere.msh  (Here  RenameMesh3D  is a simple  bash  script\nthat uses  buff-analyze .\nto count the number of interior faces in a volume mesh and rename \nthe mesh file accordingly; note that it also changes\nthe file extension from  .msh  to  .vmsh , which I find\nconvenient for distinguishing volume mesh files from\nsurface mesh files.   This produces the files  Sphere_637.msh  and  Sphere_1727.msh, \nwhich you can visualize by opening in  gmsh ::  % gmsh Sphere_637.msh   % gmsh Sphere_1727.msh   Note: As you can see from the first image here,\nby default  gmsh", 
            "title": "gmsh geometry file and volume mesh for a single sphere"
        }, 
        {
            "location": "/examples/SiO2Spheres/#buff-em-geometry-files", 
            "text": "The buff-em  geometry file  SiO2Sphere_637.buffgeo \ndescribes a single SiO2 sphere.  The  buff-em  geometry files SiO2Spheres_637.buffgeo \nand SiO2Spheres_1727.buffgeo \neach describe the same configuration: two SiO2 spheres\nseparated by a center--center distance of 10 microns.\nYou can visualize this configuration by typing e.g.  % buff-analyze --geometry SiO2Spheres_1727.buffgeo --WriteGMSHFiles\n% gmsh SiO2Spheres_1727.pp", 
            "title": "buff-em geometry files"
        }, 
        {
            "location": "/examples/SiO2Spheres/#spectral-density-of-radiated-power", 
            "text": "As described in the  buff-neq  documentation , buff-neq  computes the total power radiated by\nfinite-temperature objects as an integral over angular frequencies \\omega,  in which the integrand involves a\ntemperature-dependent Bose-Einstein factor \nand a temperature-independent dimensionless flux  \\Phi.  \nTo calculate this radiated-power flux at a given set\nof frequencies, we say   % buff-neq --geometry SiO2Sphere_637.buffgeo --OmegaFile --PRad  where  OmegaFile  is a list of\nangular frequencies. (Here  --PRad  says that we\nare interested in the radiated power).\nThis produces the file SiO2Sphere_637.SiFlux , which looks something\nlike this:  # buff-neq run on superhr2 (07/11/15::00:31:36)\n# data file columns: \n# 1 transform tag\n# 2 omega \n# 3 (sourceObject,destObject) \n# 4 PRad flux spectral density\nDEFAULT 1.000000e-01 11 4.18911788e-06 \nDEFAULT 1.300000e-01 11 1.38869207e-05 \nDEFAULT 1.600000e-01 11 3.93335327e-05 \nDEFAULT 1.900000e-01 11 1.05263974e-04   As the file header says, the second column here\nis the angular frequency \nin units of  \\omega_0=3\\cdot 10^{14}  rad/sec\nand the fourth column is the dimensionless power\nflux. (The first column lists the geometrical transformation ;\nsince \nwe didn't specify the  --transfile  option to  buff-neq , we have just a single geometric\nconfiguration, labeled  DEFAULT . The third \ncolumn identifies the source and destination objects;\nsince this geometry only has a single object,\nthe source and destination object are both \nalways object 1 and this column always reads 11 .)  Here's a plot of the data:   In this plot, the solid line is the prediction of \nthe  Krueger formalism , as computed\nby a  julia  code called  KruegerFormulas.jl .  The plot is produced by  gnuplot  using  this script .", 
            "title": "Spectral density of radiated power"
        }, 
        {
            "location": "/examples/SiO2Spheres/#spectral-density-of-power-transfer-and-non-equilibrium-force", 
            "text": "Here's a  bash script  that runs  buff-neq \nfor both the coarsely-meshed and finely-meshed two-sphere\ngeometry to compute the fluxes of power transfer\nand nonequilibrium force between the spheres. \nRunning the script produces files  SiO2Spheres_637.SIFlux \nand  SiO2Spheres_1727.SIFlux.  Here are plots (produced\nby the same  gnuplot  script referenced above)\nof the heat-transfer flux from sphere 1 to sphere 2,\nand the force fluxes from sphere 1 to sphere 2 and\nfrom sphere 2 to sphere 2, compared to the Krueger\nT-matrix results (again computed using the  julia \ncode referenced above).", 
            "title": "Spectral density of power transfer and non-equilibrium force"
        }, 
        {
            "location": "/examples/PhotonTorpedoes/", 
            "text": "Thermal self-propulsion of a photon torpedo\n\n\nIn this example we consider a warm asymmetric particle---a\n\nphoton torpedo\n---in a cold environment. The thermal\nradiation from the particle carries away not only\nenergy but also linear momentum, forcing the particle\nto recoil in the opposite direction by conservation of\nmomentum. This is the phenomenon of \nthermal self-propulsion\n, \nand we will use \nbuff-neq\n to predict the \nacceleration of a variety of torpedo designs in an \neffort to identify the maximally self-propelling\nconfiguration.", 
            "title": "Thermal radiation and self-propulsion of photon torpedoes"
        }, 
        {
            "location": "/examples/Pinwheels/", 
            "text": "Thermal self-rotation of a QED pinwheel\n\n\nIn this example we consider a warm chiral particle---a\n\nQED pinwheel\n---in a cold environment. The thermal\nradiation from the pinwheel carries away not only\nenergy but also angular momentum, forcing the pinwheel\nto begin to rotate in the opposite direction to \nconserve angular momentum. This is the phenomenon of \n\nthermal self-rotation\n, and we will use \nbuff-neq\n\nto predict the angular acceleration on a variety of\npinwheels in an effort to identify the maximally\nself-rotating design.", 
            "title": "Thermal self-rotation of QED pinwheels"
        }, 
        {
            "location": "/reference/TopLevel/", 
            "text": "Top-level overview of \nbuff-em\n\n\nbuff-em\n is a free, open-source software\nimplementation of the frequency-domain \nvolume-integral-equation (VIE) method of \nclassical electromagnetic\nscattering using \nSWG basis functions\n.\n\n\nbuff-em\n is similar in many ways to \n\nscuff-em\n,\nwhich solves similar problems using the\nalternative surface-integral-equation (SIE)\nformalism. Some key differences between these\ncodes are\n\n\n\n\n\n\nbuff-em\n can handle bodies with inhomogeneous\nand/or anisotropic dielectric permittivity. In\ncontrast, \nscuff-em\n can only handle homogeneous\nisotropic materials.\n\n\n\n\n\n\nbuff-em\n requires scatterers to be described\nby volume (tetrahedral) meshes instead of \nthe surface (triangle) meshes used by \nscuff-em\n.\n\n\n\n\n\n\nbuff-em\n does not aspire to solve the same\nbreadth of problems that \nscuff-em\n does. \nMore specifically, \nbuff-em\n is primarily\nintended for just two classes of problem: \n\n(a)\n classical scattering of known incident\nfields from compact bodies (implemented by the\ncommand-line code \n\nbuff-scatter\n, \nand \n\n(b)\n non-equilibrium fluctuational\nelectrodynamics in the fluctuating-volume-current \napproach---including radiative heat transfer, thermal \nself propulsion/rotation, and non-equilibrium Casimir \nforces---for one or more compact bodies (implemented\nby the command-line code\n\nbuff-neq\n).\n\n\n\n\n\n\n(For more on similarities and differences between\nthe two codes, see the document\n\nKey differences between \nbuff-em\n\nand \nscuff-em\n).\n\n\nLike \nscuff-em\n, \nbuff-em\n consists of a \n\ncore library\n,\nimplementing the basic VIE functionality, plus\nthe two specialized \napplication modules\n \nmentioned above for scattering and non-equilibrium\nfluctuations.\n\n\nbuff-em\n stands for \nBU\nlk \nF\nield \nF\normulation of \n\nE\nlectro\nM\nagnetism. This is a reference to the underlying solution \nmethodology used by \nbuff-em\n and other VIE solvers, in which\nthe primary goal of the solver is to compute the volume electric \ncurrent distribution throughout a compact body (which is\nlocally proportional to the local bulk electric field,\nwhereupon the name).\n\n\nLike \nscuff-em\n, the entire \nbuff-em\n suite is free software \ndistributed under the \nGNU GPL\n. The source code for\n\nbuff-em\n may be downloaded from the \n\nbuff-em\n GitHub page\n. \n\nThe GitHub page is also the right place for questions, \nbug reports, feature requests, and other discussion of \nbuff-em\n.\n\n\nNote that \nbuff-em\n requires \nscuff-em\n, so you will need a\nworking \nscuff-em\n installation on your system before you can \nstart using \nbuff-em\n.\n\n\nInterfaces to \nbuff-em\n\n\nAs is true for \nscuff-em\n, the core computational engine \nin \nbuff-em\n may be accessed via multiple interfaces.\n\n\nThe \ncommand-line interface\n consists of specialized\n\ncommand-line applications\n for\nrunning specific calculations in computational\nphysics. Using \nbuff-em\n in this way requires only\nthat you learn some basic command-line options;\nit should be possible to come quickly up to speed\nby following these\n\ntutorial examples\n.\n\n\nThe \napplication programming interface\n consists of \na \nC++ API\n\nthat allows access to internal \nbuff-em\n data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.\n\n\nInputs to \nbuff-em\n calculations\n\n\nTypical inputs to \nscuff-em\n calculations include\n\n\n\n\n\n\nA \ngeometry file\n describing the scattering geometry\n\n\n\n\n\n\nFor anisotropic or inhomogeneous bodies, an \n  \n.SVTensor\n file\n describing\n  the spatially-varying components of the permittivity\n  tensor. (\"SVTensor\" stands for \"spatially-varying tensor.\")\n\n\n\n\n\n\nSpecification of the frequencies at which you want to \n  perform calculations.\n\n\n\n\n\n\nAn optional \n  \nlist of geometric transformations\n\n  to be applied to the geometry, with calculations generally repeated\n  at each transformation. (The usage and syntax of transformations\n  in \nbuff-em\n is identical to that in \nscuff-em\n.)\n\n\n\n\n\n\nFor scattering codes: a specification of the \n  \nIncident fields\n. (Incident fields in \n  in \nbuff-em\n are handled the same way as in \nscuff-em\n.)\n\n\n\n\n\n\nSpecifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, etc.\n\n\n\n\n\n\nOutputs from \nbuff-em\n calculations\n\n\nTypical outputs from \nbuff-em\n calculations include\n\n\n\n\n\n\ntext-based data files reporting output quantities\n\n\n\n\n\n\nVisualization files written in \n  \nGMSH\n post-processing\n  format.\n\n\n\n\n\n\n\n\nCommand-line Applications\n\n\nNanophotonics / electromagnetic scattering\n\n\n\n\nbuff-scatter\n\n\nA general-purpose solver for problems involving the \nscattering of known incident fields from one or more\ncompact objects.\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; absorbed and scattered \npower; force and torque (radiation pressure); and induced \nmultipole moments.\n\n\n\n\n\n\n\n\nFluctuation-induced interactions\n\n\n\n\nbuff-neq\n\n\nAn implementation of the fluctuating-volume-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.\n\n\n\n\n\n\n\n\nCiting \nbuff-em\n\n\nIf you find \nbuff-em\n useful for generating\nresults included in publications, please consider citing both \n\n(a)\n one of the papers discussing the implementation of\n\nbuff-em\n, and\n\n(b)\n the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:\n\n\nNumerical computations were performed using {\\sc buff-em}, a free,\nopen-source software implementation of the \nvolume-integral-equation method~\\cite{BUFF1, BUFF2}.\n\n\n\n\nHere the \nBUFF1\n and \nBUFF2\n\nreferences refer to the following \n.bibtex\n entries:\n\n\n@ARTICLE{BUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle = \n{Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations}\n,\njournal = {ArXiv e-prints},\narchivePrefix = \narXiv\n,\neprint = {1307.2966},\nprimaryClass = \nphysics.comp-ph\n,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{BUFF2,\nnote=\n\\texttt{https://github.com/HomerReid/buff-em}\n\n}", 
            "title": "Top-level overview"
        }, 
        {
            "location": "/reference/TopLevel/#interfaces-to-buff-em", 
            "text": "As is true for  scuff-em , the core computational engine \nin  buff-em  may be accessed via multiple interfaces.  The  command-line interface  consists of specialized command-line applications  for\nrunning specific calculations in computational\nphysics. Using  buff-em  in this way requires only\nthat you learn some basic command-line options;\nit should be possible to come quickly up to speed\nby following these tutorial examples .  The  application programming interface  consists of \na  C++ API \nthat allows access to internal  buff-em  data structures\nand methods for maximal flexibility in implementing your\nown custom-designed physics codes.", 
            "title": "Interfaces to buff-em"
        }, 
        {
            "location": "/reference/TopLevel/#inputs-to-buff-em-calculations", 
            "text": "Typical inputs to  scuff-em  calculations include    A  geometry file  describing the scattering geometry    For anisotropic or inhomogeneous bodies, an \n   .SVTensor  file  describing\n  the spatially-varying components of the permittivity\n  tensor. (\"SVTensor\" stands for \"spatially-varying tensor.\")    Specification of the frequencies at which you want to \n  perform calculations.    An optional \n   list of geometric transformations \n  to be applied to the geometry, with calculations generally repeated\n  at each transformation. (The usage and syntax of transformations\n  in  buff-em  is identical to that in  scuff-em .)    For scattering codes: a specification of the \n   Incident fields . (Incident fields in \n  in  buff-em  are handled the same way as in  scuff-em .)    Specifications of the output quantities you wish to get back: \n  field components at individual points in space, power/force/torque\n  information, Casimir quantities, heat-transfer rates, etc.", 
            "title": "Inputs to buff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#outputs-from-buff-em-calculations", 
            "text": "Typical outputs from  buff-em  calculations include    text-based data files reporting output quantities    Visualization files written in \n   GMSH  post-processing\n  format.", 
            "title": "Outputs from buff-em calculations"
        }, 
        {
            "location": "/reference/TopLevel/#command-line-applications", 
            "text": "Nanophotonics / electromagnetic scattering   buff-scatter  A general-purpose solver for problems involving the \nscattering of known incident fields from one or more\ncompact objects.\nAvailable outputs include: scattered and total fields\nat arbitrary points in space; absorbed and scattered \npower; force and torque (radiation pressure); and induced \nmultipole moments.     Fluctuation-induced interactions   buff-neq  An implementation of the fluctuating-volume-current\napproach to non-equilibrium fluctuation-induced\ninteractions among compact objects.\nAvailable outputs include: frequency-resolved or \nfrequency-integrated rates of heat radiation or \nradiative heat transfer; non-equilibrium Casimir \nforces; self-propulsion and self-rotation of \nisolated bodies.", 
            "title": "Command-line Applications"
        }, 
        {
            "location": "/reference/TopLevel/#citing-buff-em", 
            "text": "If you find  buff-em  useful for generating\nresults included in publications, please consider citing both  (a)  one of the papers discussing the implementation of buff-em , and (b)  the URL for the code. For example, if you are writing\nin LaTeX, you might write something like this:  Numerical computations were performed using {\\sc buff-em}, a free,\nopen-source software implementation of the \nvolume-integral-equation method~\\cite{BUFF1, BUFF2}.  Here the  BUFF1  and  BUFF2 \nreferences refer to the following  .bibtex  entries:  @ARTICLE{BUFF1,\nauthor = {{Homer Reid}, M.~T. and {Johnson}, S.~G.},\ntitle =  {Efficient Computation of Power, Force, and Torque in \nBEM Scattering Calculations} ,\njournal = {ArXiv e-prints},\narchivePrefix =  arXiv ,\neprint = {1307.2966},\nprimaryClass =  physics.comp-ph ,\nkeywords = {Physics - Computational Physics, Physics - Classical Physics},\nyear = 2013,\nmonth = jul,\n}\n\n@ARTICLE{BUFF2,\nnote= \\texttt{https://github.com/HomerReid/buff-em} \n}", 
            "title": "Citing buff-em"
        }, 
        {
            "location": "/reference/Installing/", 
            "text": "Installing \nbuff-em\n\n\n1. Install \nscuff-em\n\n\nbuff-em\n requires \nscuff-em\n, so if you don't have \n\nscuff-em\n installed you will need to do that first,\nfollowing the instructions \nhere\n.\n\n\n2. External packages\n\n\nbuff-em\n doesn't require any external packages beyond\nthose required for \nscuff-em\n.\n\n\nAlthough not required to install, compile, or use\n\nbuff-em\n,\n\ngmsh\n\nis an extremely valuable open-source meshing and visualization\ntool that is used throughout the\n\nbuff-em\n documentation.\n\n\nOn Debian/Ubuntu Linux systems, you can install \ngmsh\n by\ndoing a \n\n\n% sudo apt-get install gmsh\n\n\n\n\n\n\nNote: In some cases it seems the \ngmsh\n package conflicts with \nthe \nlibhdf5-serial-dev\n package. In this case, just \nremove \ngmsh\n from the above \napt-get\n statement; you can \ninstall it by hand following the instructions\non the \nGMSH website\n.\n(Note that \ngmsh\n, though very useful, \nis not necessary to compile or run \nbuff-em\n.)\n\n\n\n\n2. Cloning the GitHub repository and building the code\n\n\nbuff-em\n is hosted on \nGitHub\n.\nTo fetch and install the latest version of the \ncode, execute the following steps. (Replace the string\n\n/path/to/buff-em-installation-directory\n\nwith your desired installation directory.)\n\n\n% git clone https://homerreid@github.com/HomerReid/buff-em.git\n% cd buff-em\n% sh autogen.sh --prefix=/path/to/buff-em-installation-directory\n% make install\n\n\n\n\nIf this succeeds, the executable versions of the application\nprograms (such as \nbuff-scatter\n, \nbuff-neq\n, etc.) will be \ninstalled in the directory \nPREFIX/bin/\n \nand the demonstration examples for the various application programs \nwill be in \nPREFIX/share/buff-em/examples\n\n(where \nPREFIX\n is the directory you specified using the \n\n--prefix\n option above).\n\n\nIf you have trouble installing \nbuff-em\n,\nplease file an issue on the \n\nbuff-em\n GitHub page\n.\n\n\nBuild options\n\n\nYou may specify options to the \nautogen.sh\n\n(or \nconfigure\n) command to guide the compilation process. \nFor a full list of available options,\ntype \nconfigure --help.\n \n\n\nIn some cases you may need to tweak certain environment \nvariables to achieve maximal \nopenmp\n performance\nwhen running (not building) \nbuff-em\n.\nFor example, on my workstation (which has 8 CPU cores),\nin order to get \nopenmp\n codes\nto use all 8 cores I need to set the following environment\nvariable:\n\n\n% export GOMP_CPU_AFFINITY=0-7", 
            "title": "Installation"
        }, 
        {
            "location": "/reference/Installing/#1-install-scuff-em", 
            "text": "buff-em  requires  scuff-em , so if you don't have  scuff-em  installed you will need to do that first,\nfollowing the instructions  here .", 
            "title": "1. Install scuff-em"
        }, 
        {
            "location": "/reference/Installing/#2-external-packages", 
            "text": "buff-em  doesn't require any external packages beyond\nthose required for  scuff-em .  Although not required to install, compile, or use buff-em , gmsh \nis an extremely valuable open-source meshing and visualization\ntool that is used throughout the buff-em  documentation.  On Debian/Ubuntu Linux systems, you can install  gmsh  by\ndoing a   % sudo apt-get install gmsh   Note: In some cases it seems the  gmsh  package conflicts with \nthe  libhdf5-serial-dev  package. In this case, just \nremove  gmsh  from the above  apt-get  statement; you can \ninstall it by hand following the instructions\non the  GMSH website .\n(Note that  gmsh , though very useful, \nis not necessary to compile or run  buff-em .)", 
            "title": "2. External packages"
        }, 
        {
            "location": "/reference/Installing/#2-cloning-the-github-repository-and-building-the-code", 
            "text": "buff-em  is hosted on  GitHub .\nTo fetch and install the latest version of the \ncode, execute the following steps. (Replace the string /path/to/buff-em-installation-directory \nwith your desired installation directory.)  % git clone https://homerreid@github.com/HomerReid/buff-em.git\n% cd buff-em\n% sh autogen.sh --prefix=/path/to/buff-em-installation-directory\n% make install  If this succeeds, the executable versions of the application\nprograms (such as  buff-scatter ,  buff-neq , etc.) will be \ninstalled in the directory  PREFIX/bin/  \nand the demonstration examples for the various application programs \nwill be in  PREFIX/share/buff-em/examples \n(where  PREFIX  is the directory you specified using the  --prefix  option above).  If you have trouble installing  buff-em ,\nplease file an issue on the  buff-em  GitHub page .  Build options  You may specify options to the  autogen.sh \n(or  configure ) command to guide the compilation process. \nFor a full list of available options,\ntype  configure --help.    In some cases you may need to tweak certain environment \nvariables to achieve maximal  openmp  performance\nwhen running (not building)  buff-em .\nFor example, on my workstation (which has 8 CPU cores),\nin order to get  openmp  codes\nto use all 8 cores I need to set the following environment\nvariable:  % export GOMP_CPU_AFFINITY=0-7", 
            "title": "2. Cloning the GitHub repository and building the code"
        }, 
        {
            "location": "/reference/Geometries/", 
            "text": "Geometry descriptions in \n     \nbuff-em\n\n\n\n\n\nGeometries in \nbuff-em\n are described by simple text files \nthat are conventionally given the file extension \n.buffgeo\n.\n\n\nTable of Contents\n\n\n1. Syntax of the .buffgeo file\n\n\n2. Examples of \nbuff-em\n geometries\n\n\na. An SiO2 sphere coated with a layer of gold\n\n\nb. Two gold spheres, described by the same volume mesh but separated 3 length units in the z direction\n\n\n\n\n\n\n\n\n\n\n1. Syntax of the \n.buffgeo\n file\n\n\nThe \n.buffgeo\n file consists of one or more sections,\ndelineated by the keywords \nOBJECT...ENDOBJECT.\n\nEach section defines a single compact object in a scattering\ngeometry and takes the form\n\n\nOBJECT Label\n    KEYWORD argument\n    KEYWORD argument\n    ...\nENDOBJECT\n\n\n\n\nwhere the various possible \nKEYWORD argument\n pairs are\ndetailed below.\n\n\n\n\nMESHFILE MyMeshFile.vmsh\n\n\n\n\nSpecifies the 3D (tetrahedra) volume mesh defining the object.\nThe file should be present either in the current working \ndirectory or in the search path specified by the environment\nvariable \nBUFF_MESH_PATH\n.\n\n\n3D volume meshes are generated from a \ngmsh\n geometry \nfile by running \n%gmsh -3 MyObject.geo\n; this will produce a \nfile named \nMyObject.msh\n, which I typically rename to \n\nMyObject.vmsh\n to indicate that it is a \nvolume\n mesh\nas opposed to the surface mesh files used by \nscuff-em\n.\n\n\n\n\nMATERIAL GOLD\n\n\nSVTENSOR MyMaterial.SVTensor\n\n\n\n\nSpecifies the material properties of the object. \n\n\nThe \nMATERIAL\n keyword is used for homogeneous isotropic\nbodies. In this case, \nGOLD\n should be a\n\nscuff-em\n material designation\n.\nThis may be defined either in a database file (such as the\nfile \n${HOME}/.matprop.dat\n or \n./matprop.dat\n) or on the fly\nin your \n.buffgeo\n file by including a \nMATERIAL...ENDMATERIAL\n\nsection before your object definition.\n\n\nThe alternative \nSVTENSOR\n keyword is used for inhomogeneous \nand/or anisotropic materials. (It stands for \"spatially-varying\ntensor.\") In this case, \nMyMaterial.SVTensor\n\nshould be a \n\nbuff-em\n spatially-varying tensor file\n\npresent either in the current working directory or in the search\npath defined by the environment variable \nBUFF_SVTENSOR_PATH\n.\n\n\n\n\nDISPLACED 2.3 4.5 6.7\n\n\nROTATED 90 ABOUT 0 0 1\n\n\n\n\nThese options specify geometrical transformations to be\nperformed on the object after it has been read in from the\n\n.vmsh\n file.\n\n\n2. Examples of \nbuff-em\n geometries\n\n\na. An SiO2 sphere coated with a layer of gold\n\n\nOBJECT CoatedSphere\n    MESHFILE CoatedSphere_4017.vmsh\n    SVTENSOR CoatedSphere.SVTensor\nENDOBJECT\n\n\n\n\nThe file \nCoatedSphere.SVTensor\n is described \nhere\n.\n\n\nb. Two gold spheres, described by the same volume mesh but separated 3 length units in the \nz\n direction\n\n\nMATERIAL GOLD\n    wp = 1.37e16; \n    gamma = 5.32e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nOBJECT UpperSphere\n    MESHFILE Sphere_677.vmsh\n    MATERIAL Gold\nENDOBJECT\n\nOBJECT LowerSphere\n    MESHFILE Sphere_677.vmsh\n    MATERIAL Gold\n    DISPLACED 0 0 3\nENDOBJECT", 
            "title": "Geometry descriptions"
        }, 
        {
            "location": "/reference/Geometries/#2-examples-of-buff-em-geometries", 
            "text": "", 
            "title": "2. Examples of buff-em geometries"
        }, 
        {
            "location": "/reference/Geometries/#a-an-sio2-sphere-coated-with-a-layer-of-gold", 
            "text": "OBJECT CoatedSphere\n    MESHFILE CoatedSphere_4017.vmsh\n    SVTENSOR CoatedSphere.SVTensor\nENDOBJECT  The file  CoatedSphere.SVTensor  is described  here .", 
            "title": "a. An SiO2 sphere coated with a layer of gold"
        }, 
        {
            "location": "/reference/Geometries/#b-two-gold-spheres-described-by-the-same-volume-mesh-but-separated-3-length-units-in-the-z-direction", 
            "text": "MATERIAL GOLD\n    wp = 1.37e16; \n    gamma = 5.32e13;\n    Eps(w) = 1 - wp^2 / (w * (w + i*gamma));\nENDMATERIAL\n\nOBJECT UpperSphere\n    MESHFILE Sphere_677.vmsh\n    MATERIAL Gold\nENDOBJECT\n\nOBJECT LowerSphere\n    MESHFILE Sphere_677.vmsh\n    MATERIAL Gold\n    DISPLACED 0 0 3\nENDOBJECT", 
            "title": "b. Two gold spheres, described by the same volume mesh but separated 3 length units in the z direction"
        }, 
        {
            "location": "/reference/SVTensors/", 
            "text": "Spatially-varying permittivity tensors in\n     \nbuff-em\n\n\n\n\n\nbuff-em\n supports objects with arbitrary user-specified\nspatially-varying frequency-dependent permittivity tensors.\nThese tensors are described by simple text files conventionally\ngiven the file extension \n.SVTensor.\n\n\nThe \n.SVTensor\n file is thought of as describing a\n3\n\\times\n3 matrix-valued function\n\n\\mathbf{Q}\n of frequency and space:\n\n\n\n\n\\mathbf{Q}(\\omega, \\mathbf x)=\\left(\\begin{array}{ccc}\n Q_{xx}(\\omega, \\mathbf x) & \n Q_{xy}(\\omega, \\mathbf x) & \n Q_{xz}(\\omega, \\mathbf x) \\\\\n Q_{yx}(\\omega, \\mathbf x) & \n Q_{yy}(\\omega, \\mathbf x) & \n Q_{yz}(\\omega, \\mathbf x) \\\\\n Q_{zx}(\\omega, \\mathbf x) & \n Q_{zy}(\\omega, \\mathbf x) & \n Q_{zz}(\\omega, \\mathbf x)\n\\end{array}\\right)\n\n\n\n\nTable of Contents\n\n\n1. Syntax of the .SVTensor file\n\n\nFunctions and variables\n\n\nReferring to scuff-em material designations\n\n\n\n\n\n\n\n\n\n\n2. Examples of .SVTensor files\n\n\n1. An isotropic but spatially-varying permittivity\n\n\n2. A non-isotropic permittivity\n\n\n3. A gold-coated SiO2 sphere\n\n\n4. A gold/SiO2 Janus particle\n\n\n\n\n\n\n\n\n\n\n1. Syntax of the \n.SVTensor\n file\n\n\nThe \n.SVTensor\n file contains lines of the form \n\n\n\n\nQ =\n \nfunction of space and frequency\n\n\n\n\nto define a spatially-varying but isotropic permittivity\n(proportional to the \n3 \\times 3\n identity matrix), or\n\n\n\n\nQxx =\n \nfunction of space and frequency\n\n\nQxy =\n \nfunction of space and frequency\n\n\n...\n\n\nQzz =\n \nfunction of space and frequency\n\n\n\n\nto define the individual cartesian components of the\npermittivity tensor.\n\n\nNote: Because \n.SVTensor\n files are most commonly\nused to define permittivities \n\\boldsymbol{\\epsilon}\n, \nyou can alternatively use the syntax\n\n\n\n\nEps =\n \nfunction of space and frequency\n\n\n\n\nor \n\n\n\n\nEpsXX =\n \nfunction of space and frequency\n\n\nEpsXY =\n \nfunction of space and frequency\n\n\n... \n\n\nEpsZZ =\n \nfunction of space and frequency\n\n\n\n\nIf you leave any off-diagonal components unspecified,\nthey will be assumed to be zero. If you do specify an \noff-diagonal component function, you only need to specify\n\neither\n the above-diagonal \nor\n the below-diagonal component,\ne.g. \nQxy\n but not also \nQyx\n; the code will automatically\nset \nQ_{yx}=Q_{xy}\n. If you do specify two separate functions\nfor the two off-diagonal components of \n\\mathbf{Q}\n, the code\nwill symmetrize by setting both components equal to \ntheir average.\n\n\nFor diagonal components, if you specify \nQxx\n but omit\nspecifications for \nQyy\n and \nQzz\n then the code\nwill set \nQ_{yy}=Q_{zz}=Q_{xx}.\n\n\n\n\nFunctions and variables\n\n\nThe user-defined \nfunction of space and frequency\n in the\ndefinition of permittivity components is a character string\nthat may refer to any of the following variables:\n\n\n\n\nw\n           (the angular frequency in units of 3e14 rad/sec)\n\n\nx,y,z\n       (cartesian coordinates of points in space)\n\n\nr,Theta,Phi\n (spherical coordinates of points in space)\n\n\n\n\nReferring to \nscuff-em\n material designations\n\n\nIn many cases your permittivity functions will want to refer to\n\nscuff-em\n material designations\n\ndescribing frequency-dependent homogeneous isotropic materials.\nYou can do this by including the string \nMP_MATNAME\n\nin the function definition, where \nMATNAME\n is the name\nof the \nscuff-em\n material.\nFor example, here is a description of a material\ntensor that varies continuously from 100% gold to \n100% silicon dioxide as the \nz\n coordinate runs\nfrom 0 to 1:\n\n\n Eps = MP_SIO2 * z + MP_GOLD*(1-z)\n\n\n\n\nNote that there is no need to refer to the frequency \nw\n \nhere; the \nGOLD\n and \nSIO2\n permittivities will automatically\nby evaluated at the correct frequency.\n\n\nThe definitions for the \nscuff-em\n materials \n(\nSIO2\n and \nGOLD\n in this case) may appear in\n\nMATERIAL...ENDMATERIAL\n sections within the \n.SVTensor\n\nfile; alternatively, they may be defined in the\nglobal database file \n${HOME}/.matprop.dat\n\nor the local data file \nmatprop.dat\n in the current\nworking directory.\n\n\n2. Examples of \n.SVTensor\n files\n\n\n1. An isotropic but spatially-varying permittivity\n\n\nHere's an isotropic material whose dielectric\nconstant varies linearly as a function of the \nz\n-coordinate,\nfrom a value of \n\\epsilon=5+\\frac{4i}{\\omega}\n at\n\nz=-5\n to a value of \n\\epsilon=10+\\frac{8i}{\\omega}\n\nat \nz=+5\n:\n\n\n Eps = (5 + 4*i/w)*(1 + (z+5)/10 )\n\n\n\n\n2. A non-isotropic permittivity\n\n\nThis example describes the constant permittivity tensor\n\n\\boldsymbol{\\epsilon}=\n \\left(\\begin{array}{ccc} 2+3i & 0.01 & 0    \\\\\n                          0.01 & 2+3i & 0.00 \\\\\n                          0    &    0 & 4.5i \\\\\n       \\end{array}\\right)\n:\n\n\nEpsXX=2+3i\nEpsXY=0.1\nEpsZZ=4+5i\n\n\n\n\n\n\n3. A gold-coated SiO2 sphere\n\n\nThis example is used to describe a silicon dioxide sphere of \nradius 2 um coated with a layer of gold.\nNote that \nstep\n refers to the Heaviside step function.\n\n\n Eps = step(2-r)*MP_SIO2 + step(r-2)*MP_GOLD\n\n\n\n\n4. A gold/SiO2 Janus particle\n\n\nIn this case the material is gold at points above the \nxy\n plane\nand SiO2 at points below the \nxy\n plane.\n\n\n Eps = step(z)*MP_GOLD + step(-z)*MP_SIO2", 
            "title": "Inhomogeneous/anisotropic materials"
        }, 
        {
            "location": "/reference/SVTensors/#functions-and-variables", 
            "text": "The user-defined  function of space and frequency  in the\ndefinition of permittivity components is a character string\nthat may refer to any of the following variables:   w            (the angular frequency in units of 3e14 rad/sec)  x,y,z        (cartesian coordinates of points in space)  r,Theta,Phi  (spherical coordinates of points in space)   Referring to  scuff-em  material designations  In many cases your permittivity functions will want to refer to scuff-em  material designations \ndescribing frequency-dependent homogeneous isotropic materials.\nYou can do this by including the string  MP_MATNAME \nin the function definition, where  MATNAME  is the name\nof the  scuff-em  material.\nFor example, here is a description of a material\ntensor that varies continuously from 100% gold to \n100% silicon dioxide as the  z  coordinate runs\nfrom 0 to 1:   Eps = MP_SIO2 * z + MP_GOLD*(1-z)  Note that there is no need to refer to the frequency  w  \nhere; the  GOLD  and  SIO2  permittivities will automatically\nby evaluated at the correct frequency.  The definitions for the  scuff-em  materials \n( SIO2  and  GOLD  in this case) may appear in MATERIAL...ENDMATERIAL  sections within the  .SVTensor \nfile; alternatively, they may be defined in the\nglobal database file  ${HOME}/.matprop.dat \nor the local data file  matprop.dat  in the current\nworking directory.", 
            "title": "Functions and variables"
        }, 
        {
            "location": "/reference/SVTensors/#2-examples-of-svtensor-files", 
            "text": "", 
            "title": "2. Examples of .SVTensor files"
        }, 
        {
            "location": "/reference/SVTensors/#1-an-isotropic-but-spatially-varying-permittivity", 
            "text": "Here's an isotropic material whose dielectric\nconstant varies linearly as a function of the  z -coordinate,\nfrom a value of  \\epsilon=5+\\frac{4i}{\\omega}  at z=-5  to a value of  \\epsilon=10+\\frac{8i}{\\omega} \nat  z=+5 :   Eps = (5 + 4*i/w)*(1 + (z+5)/10 )", 
            "title": "1. An isotropic but spatially-varying permittivity"
        }, 
        {
            "location": "/reference/SVTensors/#2-a-non-isotropic-permittivity", 
            "text": "This example describes the constant permittivity tensor \\boldsymbol{\\epsilon}=\n \\left(\\begin{array}{ccc} 2+3i & 0.01 & 0    \\\\\n                          0.01 & 2+3i & 0.00 \\\\\n                          0    &    0 & 4.5i \\\\\n       \\end{array}\\right) :  EpsXX=2+3i\nEpsXY=0.1\nEpsZZ=4+5i", 
            "title": "2. A non-isotropic permittivity"
        }, 
        {
            "location": "/reference/SVTensors/#3-a-gold-coated-sio2-sphere", 
            "text": "This example is used to describe a silicon dioxide sphere of \nradius 2 um coated with a layer of gold.\nNote that  step  refers to the Heaviside step function.   Eps = step(2-r)*MP_SIO2 + step(r-2)*MP_GOLD", 
            "title": "3. A gold-coated SiO2 sphere"
        }, 
        {
            "location": "/reference/SVTensors/#4-a-goldsio2-janus-particle", 
            "text": "In this case the material is gold at points above the  xy  plane\nand SiO2 at points below the  xy  plane.   Eps = step(z)*MP_GOLD + step(-z)*MP_SIO2", 
            "title": "4. A gold/SiO2 Janus particle"
        }, 
        {
            "location": "/reference/BUFFvsSCUFF/", 
            "text": "Key differences between \nbuff-em\n and \nscuff-em\n\n\nDifferences in capabilities\n\n\nWhat \nbuff-em\n can do that \nscuff-em\n can't do\n\n\n\n\n\n\nbuff-em\n can handle objects with anisotropic and/or\ncontinuously spatially varying dielectric permittivity.\nThe components of the 3x3 dielectric tensor may be \nany arbitrary user-specified functions of space and\nfrequency.\n\n\n\n\n\n\nThe volume-integral technique used by \nbuff-em\n to\nhandle non-equilibrium Casimir forces and torques is\nsignificantly faster than the surface-integral\ntechnique used by \nscuff-em\n.\n\n\n\n\n\n\nWhat \nbuff-em\n \ncan't\n do that \nscuff-em\n can do\n\n\n\n\n\n\nbuff-em\n does not currently support extended objects \nor periodic boundary conditions; all bodies must be compact \nobjects. This may change in a later version of the code.\n\n\n\n\n\n\nbuff-em\n does not currently support magnetic materials \n(\n\\mu \\ne 1\n). This may change in a later version of the\ncode.\n\n\n\n\n\n\nbuff-em\n does not support perfectly electrically\nconducting (PEC) bodies or bodies with surface\nconductivity. This \nwill not change\n in later versions\nof the code, because these idealizations are not\nsupported by the underlying formulation of \nelectromagnetism (the volume-integral-equation\napproach) implemented by the \nbuff-em\n core library.\n\n\n\n\n\n\nDifferences in input files\n\n\n\n\n\n\nGeometry files in \nbuff-em\n are conventionally\ngiven the extension \n.buffgeo\n instead of \n.scuffgeo\n\nas in \nscuff-em\n.\n\n\n\n\n\n\nMesh files---which describe collections of tetrahedra,\nnot collections of triangles---are conventionally given the \nextension \n.vmsh\n instead of \n.msh\n. (Tetrahedral meshes\nmay be generated in \ngmsh\n using the command-line \nargument \n-3\n as opposed to \n-2\n for triangular meshes.\nThis will produce a \n.msh\n file, which will be automatically\nrenamed to a \n.vmsh\n file by this \nbash\n script:\n\nRenameMesh3D\n.\n\n\n\n\n\n\nbuff-em\n looks for mesh files in the current\n  working directory and in the directory specified\n  by the environment variables \nBUFF_MESH_DIR.\n\n\n\n\n\n\n\n\nDifferences in caching\n\n\n\n\n\n\nThe discretized integral-equation formalisms implemented\nby \nbuff-em\n and \nscuff-em\n are similar in one key\nrespect: the assembly of the system matrix required\nto solve scattering problems involves the computation of \nlarge numbers of singular multidimensional integrals. To\naccelerate this task, both \nbuff-em\n and \nscuff-em\n\nimplement a \ncaching\n scheme in which certain \nfrequency-independent contributions to matrix elements\nfor a given structure\nare stored in binary data files to allow them to be\nreused in subsequent calculations on the same structure.\n\n\n\n\n\n\nHowever, whereas caching is considered as a somewhat\noptional acceleration feature in \nscuff-em\n,\nit is treated as \nmandatory\n in \nbuff-em\n, because\nthe speedup afforded by caching is much greater\nin this case (essentially because the singular\nintegrals in question are now 6-dimensional instead \nof 4-dimensional and thus much more expensive to \ncompute from scratch; the acceleration enabled\nby caching thus makes a greater difference).\n\n\n\n\n\n\nFor this reason, the caching process in \nbuff-em\n\nis designed to be largely transparent to the user;\nin particular, there are no cache-related command-line\narguments to application codes. Instead, for each meshed \nobject (each \n.vmsh\n file) specified in a \n.buffgeo\n \nfile, \nbuff-em\n looks \nautomatically\n for the cache \nfile; if no file is found, \nbuff-em\n \nautomatically\n \nwrites this file to disk after the first matrix assembly.\n\n\n\n\n\n\nThe cache file associated to a meshed object\ndescribed by a \ngmsh\n file named \nObject.vmsh\n is\nalways named \nObject.cache.\n Before the first\nmatrix assembly, \nbuff-em\n looks for\nthis file in a couple of different places:\n\n\n\n\n\n\n\n\n\n\nThe current working directory\n\n\nThe directory specified by the environment variable\n\nBUFF_CACHE_DIR\n\n\n\n\n\n\n\n\n\n\nIf the \n.cache\n file is not found in either location,\n\nbuff-em\n computes all integrals from scratch\nwhen it first assembles the system matrix (that is,\nwhen it handles the first user-specified frequency)\nand then writes the file to disk as soon as that\nassembly is complete. If the environment variable\n\nBUFF_CACHE_DIR\n is set, \nbuff-em\n writes the\n\n.cache\n file to the directory it specifies; otherwise,\nthe file is written to the current working directory.\n\n\n\n\n\n\nAs in \nscuff-em\n, the \n.cache\n file is \n\nindependent of frequency and material properties\n,\nso it only needs to be computed \nonce\n for\na given \n.vmsh\n file, after which it may be \nreused for different computations on that object\nat different frequencies and even different \nmaterial properties (including \n\nanisotropic or inhomogeneous materials\n).\n\n\n\n\n\n\nThe code \nbuff-analyze\n\noffers the command-line option \n--WriteGCache\n to precompute\nand write to disk the \n.cache\n files for a given \n.vmsh\n file. \nThus, before you start any \nbuff-em\n calculation,\nyou can say \n\n\n\n\n\n\n % buff-analyze --MeshFile Object.vmsh --WriteGCache\n\n\n\n\nThis will create a file named \nObject.cache\n in the\ncurrent working directory (or in the directory\nspecified by \nBUFF_CACHE_DIR\n if it is set). Although\nthis will take some time to complete, the advantage \nis that your calculations will run quickly already \non the first frequency.\n\n\nDifferences in the underlying formalism\n\n\n\n\nThe computational paradigm employed by \nscuff-em\n\nseparates space into contiguous homogeneous regions\nbounded by closed surfaces. The fields in any\nregion are determined solely from knowledge of the \nsurface currents on the surfaces bounding that surface\n(together with the fields of any bulk sources that \nexist within the region).\n\n\n\n\nIn \nbuff-em\n there is no such separation. Instead,\nall objects exist in a single ginormous all-encompassing\nhomogeneous region (the vacuum) and the fields at any \npoint receive contributions from all objects and from\nany incident-field sources that may be present.", 
            "title": "Key differences between BUFF and SCUFF"
        }, 
        {
            "location": "/reference/BUFFvsSCUFF/#differences-in-capabilities", 
            "text": "What  buff-em  can do that  scuff-em  can't do    buff-em  can handle objects with anisotropic and/or\ncontinuously spatially varying dielectric permittivity.\nThe components of the 3x3 dielectric tensor may be \nany arbitrary user-specified functions of space and\nfrequency.    The volume-integral technique used by  buff-em  to\nhandle non-equilibrium Casimir forces and torques is\nsignificantly faster than the surface-integral\ntechnique used by  scuff-em .    What  buff-em   can't  do that  scuff-em  can do    buff-em  does not currently support extended objects \nor periodic boundary conditions; all bodies must be compact \nobjects. This may change in a later version of the code.    buff-em  does not currently support magnetic materials \n( \\mu \\ne 1 ). This may change in a later version of the\ncode.    buff-em  does not support perfectly electrically\nconducting (PEC) bodies or bodies with surface\nconductivity. This  will not change  in later versions\nof the code, because these idealizations are not\nsupported by the underlying formulation of \nelectromagnetism (the volume-integral-equation\napproach) implemented by the  buff-em  core library.", 
            "title": "Differences in capabilities"
        }, 
        {
            "location": "/reference/BUFFvsSCUFF/#differences-in-input-files", 
            "text": "Geometry files in  buff-em  are conventionally\ngiven the extension  .buffgeo  instead of  .scuffgeo \nas in  scuff-em .    Mesh files---which describe collections of tetrahedra,\nnot collections of triangles---are conventionally given the \nextension  .vmsh  instead of  .msh . (Tetrahedral meshes\nmay be generated in  gmsh  using the command-line \nargument  -3  as opposed to  -2  for triangular meshes.\nThis will produce a  .msh  file, which will be automatically\nrenamed to a  .vmsh  file by this  bash  script: RenameMesh3D .    buff-em  looks for mesh files in the current\n  working directory and in the directory specified\n  by the environment variables  BUFF_MESH_DIR.", 
            "title": "Differences in input files"
        }, 
        {
            "location": "/reference/BUFFvsSCUFF/#differences-in-caching", 
            "text": "The discretized integral-equation formalisms implemented\nby  buff-em  and  scuff-em  are similar in one key\nrespect: the assembly of the system matrix required\nto solve scattering problems involves the computation of \nlarge numbers of singular multidimensional integrals. To\naccelerate this task, both  buff-em  and  scuff-em \nimplement a  caching  scheme in which certain \nfrequency-independent contributions to matrix elements\nfor a given structure\nare stored in binary data files to allow them to be\nreused in subsequent calculations on the same structure.    However, whereas caching is considered as a somewhat\noptional acceleration feature in  scuff-em ,\nit is treated as  mandatory  in  buff-em , because\nthe speedup afforded by caching is much greater\nin this case (essentially because the singular\nintegrals in question are now 6-dimensional instead \nof 4-dimensional and thus much more expensive to \ncompute from scratch; the acceleration enabled\nby caching thus makes a greater difference).    For this reason, the caching process in  buff-em \nis designed to be largely transparent to the user;\nin particular, there are no cache-related command-line\narguments to application codes. Instead, for each meshed \nobject (each  .vmsh  file) specified in a  .buffgeo  \nfile,  buff-em  looks  automatically  for the cache \nfile; if no file is found,  buff-em   automatically  \nwrites this file to disk after the first matrix assembly.    The cache file associated to a meshed object\ndescribed by a  gmsh  file named  Object.vmsh  is\nalways named  Object.cache.  Before the first\nmatrix assembly,  buff-em  looks for\nthis file in a couple of different places:      The current working directory  The directory specified by the environment variable BUFF_CACHE_DIR      If the  .cache  file is not found in either location, buff-em  computes all integrals from scratch\nwhen it first assembles the system matrix (that is,\nwhen it handles the first user-specified frequency)\nand then writes the file to disk as soon as that\nassembly is complete. If the environment variable BUFF_CACHE_DIR  is set,  buff-em  writes the .cache  file to the directory it specifies; otherwise,\nthe file is written to the current working directory.    As in  scuff-em , the  .cache  file is  independent of frequency and material properties ,\nso it only needs to be computed  once  for\na given  .vmsh  file, after which it may be \nreused for different computations on that object\nat different frequencies and even different \nmaterial properties (including  anisotropic or inhomogeneous materials ).    The code  buff-analyze \noffers the command-line option  --WriteGCache  to precompute\nand write to disk the  .cache  files for a given  .vmsh  file. \nThus, before you start any  buff-em  calculation,\nyou can say      % buff-analyze --MeshFile Object.vmsh --WriteGCache  This will create a file named  Object.cache  in the\ncurrent working directory (or in the directory\nspecified by  BUFF_CACHE_DIR  if it is set). Although\nthis will take some time to complete, the advantage \nis that your calculations will run quickly already \non the first frequency.", 
            "title": "Differences in caching"
        }, 
        {
            "location": "/reference/BUFFvsSCUFF/#differences-in-the-underlying-formalism", 
            "text": "The computational paradigm employed by  scuff-em \nseparates space into contiguous homogeneous regions\nbounded by closed surfaces. The fields in any\nregion are determined solely from knowledge of the \nsurface currents on the surfaces bounding that surface\n(together with the fields of any bulk sources that \nexist within the region).   In  buff-em  there is no such separation. Instead,\nall objects exist in a single ginormous all-encompassing\nhomogeneous region (the vacuum) and the fields at any \npoint receive contributions from all objects and from\nany incident-field sources that may be present.", 
            "title": "Differences in the underlying formalism"
        }, 
        {
            "location": "/applications/buff-scatter/", 
            "text": "Solving electromagnetic scattering problems with\n     \nbuff-scatter\n\n\n\n\n\nbuff-scatter\n is a tool within the \nbuff-em\n code suite\nfor solving classical scattering problems involving\nuser-specified incident fields impinging on a material\ngeometry.\n\n\nTo run a scattering calculation in \nbuff-scatter\n, you will\n\n\n\n\n\n\nCreate a \nbuff-em\n geometry file\n describing your geometry. This will involve generating tetrahedral mesh representations of each object in your geometry and possibly writing a \n.SVTensor\n file to describe any objects with anisotropic and/or inhomogeneous permittivity.\n\n\n\n\n\n\nSpecify the incident field that will impinge on your objects:\n  a plane wave, a gaussian beam, a point dipole radiator,\n  or some combination.\n\n\n\n\n\n\nRun \nbuff-scatter\n with command-line options specifying \n  the geometry, the incident fields, the frequencies at which you\n  wish to calculate, and the types of output you want to get back.\n\n\n\n\n\n\nThe types of output you can request from \nbuff-scatter\n include\n\n\n\n\n\n\nThe components of the scattered and total electric and magnetic\nfields at an arbitrary list of evaluation points you provide.\n\n\n\n\n\n\nThe absorbed power, scattered power, force, and torque for \neach object in the geometry.\n\n\n\n\n\n\nData on the electric and magnetic dipole moments induced\n  by the incident field on each object.\n\n\n\n\n\n\nVisualization files plotting the distribution of induced\ncurrent within each object.\n\n\n\n\n\n\nTable of Contents\n\n\n1. \nbuff-scatter\n command-line options\n\n\nCommon options\n\n\nOptions defining the incident field\n\n\nOptions requesting scattered and total fields\n\n\nOptions requesting power, force, and torque (PFT) data\n\n\n\n\n\n\n2. \nbuff-scatter\n examples\n\n\n\n\n\n\n\n\n1. \nbuff-scatter\n command-line options\n\n\nCommon options\n\n\nbuff-scatter\n recognizes the following subset of the\nlist of commonly accepted options to \nbuff-em\n command-line codes;\nthese all have the same meaning as the\n[corresponding options in \nscuff-em\n][scuffOptions].\n (In general, almost everything mentioned in the\n\nGeneral reference for \nscuff-em\n command-line applications\n \npertains to \nbuff-em\n command-line applications as well.)\n\n\n--geometry \n--Omega\n--OmegaFile\n\n\nOptions defining the incident field\n\n\nThe options for specifying incident fields in\n\nbuff-scatter\n are identical to those in \nscuff-scatter\n,\nas described in detail on the page\n\nIncident fields in \nscuff-em\n.\nHere we only summarize the available options without commentary.\n\n\n--pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez\n\n\n--psStrength Px Py Pz\n--psLocation xx yy zz\n\n\n--gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W\n\n\n(As in \nscuff-scatter\n, these options may occur multiple times \nto define superpositions of multiple types of incident field.)\n\n\nOptions requesting scattered and total fields\n\n\n--EPFile MyEPFile\n\n\nSpecifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points. \n\n\nThe \n--EPFile\n in \nbuff-scatter\n is identical to \nthat in \nscuff-scatter\n; for details, see the \n\nscuff-scatter\n documentation\n\n\nOptions requesting power, force, and torque (PFT) data\n\n\n--PFTFile   MyFile.PFT\n\n\nRequests that data on the absorbed and scattered power,\nforce, and torque for all bodies in the geometry be\nwritten to the file \nMyFile.PFT\n. See the file header\nin the output file for details on how to interpret its\ncontents.\n\n\n--OPFTFile     MyFile.OPFT\n --JDEPFTFile   MyFile.JDEPFT\n --DSIPFTFile   MyFile.DSIPFT\n\n\nThese options are similar to \n--PFTFile\n, but they \nrequest PFT calculations by specific algorithms: \nthe \"overlap\" (OPFT) method, the \"J dot E\" (JDEPFT) \nmethod, or the \"displaced surface-integral\" (DSIPFT)\nmethod. Note that JDEPFT is the default, so \nthe options \n--PFTFile\n and \n--JDEPFTFile\n are\nactually synonymous (if you specify both, only\none output file will be produced).\n\n\n--DSIRadius 5.0\n --DSIPoints 302\n\n\n--DSIMesh   MyBoundingMesh.msh\n\n\nThese options control the behavior of DSIPFT calculations.\nThe surface integral may be evaluated in one of two\nways: \n(a)\n by Lebedev cubature over a bounding sphere\nsurrounding the object, or \n(b)\n using a user-supplied\nbounding surface mesh. \n\n\nFor case \n(a)\n, the bounding sphere radius is set\nby \n--DSIRadius\n, while the number of cubature points\nis set by \n--DSIPoints\n. Type \nbuff-scatter --help\n\nto see list of allowed values for \n--DSIPoints.\n\n\nFor case \n(b)\n, \nMyBoundingMesh.msh\n should be a\n\ngmsh\n mesh file describing a closed bounding\nsurface discretized into triangles.\n\n\nLebedev cubature generally yields better accuracy for \nthe same number of cubature points; however, if your \ngeometry contains closely-spaced objects\nwhich cannot be enclosed in a bounding sphere without\nalso encompassing other objects, you will need to \nuse \n--DSIMesh.\n\n\n\n\n2. \nbuff-scatter\n examples\n\n\n\n\nMie scattering\n\n\nPower, force, and torque on Janus particles irradiated by plane waves", 
            "title": "buff-scatter"
        }, 
        {
            "location": "/applications/buff-scatter/#options-defining-the-incident-field", 
            "text": "The options for specifying incident fields in buff-scatter  are identical to those in  scuff-scatter ,\nas described in detail on the page Incident fields in  scuff-em .\nHere we only summarize the available options without commentary.  --pwDirection    nx ny nz\n--pwPolarization Ex Ey Ez  --psStrength Px Py Pz\n--psLocation xx yy zz  --gbDirection nx ny nz\n--gbPolarization Ex Ey Ez\n--gbCenter Cx Cy Cz\n--gbWaist W  (As in  scuff-scatter , these options may occur multiple times \nto define superpositions of multiple types of incident field.)", 
            "title": "Options defining the incident field"
        }, 
        {
            "location": "/applications/buff-scatter/#options-requesting-scattered-and-total-fields", 
            "text": "--EPFile MyEPFile  Specifies a list of evaluation points at which to\ncompute and report components of the scattered and total\nfields. This option may be specified more than once to \ndefine multiple sets of field evaluation points.   The  --EPFile  in  buff-scatter  is identical to \nthat in  scuff-scatter ; for details, see the  scuff-scatter  documentation", 
            "title": "Options requesting scattered and total fields"
        }, 
        {
            "location": "/applications/buff-scatter/#options-requesting-power-force-and-torque-pft-data", 
            "text": "--PFTFile   MyFile.PFT  Requests that data on the absorbed and scattered power,\nforce, and torque for all bodies in the geometry be\nwritten to the file  MyFile.PFT . See the file header\nin the output file for details on how to interpret its\ncontents.  --OPFTFile     MyFile.OPFT\n --JDEPFTFile   MyFile.JDEPFT\n --DSIPFTFile   MyFile.DSIPFT  These options are similar to  --PFTFile , but they \nrequest PFT calculations by specific algorithms: \nthe \"overlap\" (OPFT) method, the \"J dot E\" (JDEPFT) \nmethod, or the \"displaced surface-integral\" (DSIPFT)\nmethod. Note that JDEPFT is the default, so \nthe options  --PFTFile  and  --JDEPFTFile  are\nactually synonymous (if you specify both, only\none output file will be produced).  --DSIRadius 5.0\n --DSIPoints 302  --DSIMesh   MyBoundingMesh.msh  These options control the behavior of DSIPFT calculations.\nThe surface integral may be evaluated in one of two\nways:  (a)  by Lebedev cubature over a bounding sphere\nsurrounding the object, or  (b)  using a user-supplied\nbounding surface mesh.   For case  (a) , the bounding sphere radius is set\nby  --DSIRadius , while the number of cubature points\nis set by  --DSIPoints . Type  buff-scatter --help \nto see list of allowed values for  --DSIPoints.  For case  (b) ,  MyBoundingMesh.msh  should be a gmsh  mesh file describing a closed bounding\nsurface discretized into triangles.  Lebedev cubature generally yields better accuracy for \nthe same number of cubature points; however, if your \ngeometry contains closely-spaced objects\nwhich cannot be enclosed in a bounding sphere without\nalso encompassing other objects, you will need to \nuse  --DSIMesh.", 
            "title": "Options requesting power, force, and torque (PFT) data"
        }, 
        {
            "location": "/applications/buff-scatter/#2-buff-scatter-examples", 
            "text": "Mie scattering  Power, force, and torque on Janus particles irradiated by plane waves", 
            "title": "2. buff-scatter examples"
        }, 
        {
            "location": "/applications/buff-neq/", 
            "text": "Modeling non-equilibrium electromagnetic fluctuations with\n     \nbuff-neq\n\n\n\n\n\nbuff-neq\n is an application code in the \nbuff-em\n suite for \nstudying non-equilibrium (NEQ) electromagnetic-fluctuation-induced \nphenomena--specifically, for computing \nradiative heat-transfer rates\n \nand \nnon-equilibrium Casimir forces and torques\n for bodies of \narbitrary shapes and arbitrary (linear, isotropic, piecewise \nhomogeneous) frequency-dependent permittivity and permeability.\n\nbuff-neq\n implements the\n\nfluctuating-volume current (FVC)\n approach\nto numerical modeling of non-equilibrium fluctuation phenomena\n.\n\n\nMechanically, working with \nbuff-neq\n is similar in many ways to\nworking with the non-equilibrium Casimir code \n\nscuff-neq\n in the \nscuff-em\n code suite.\nIn particular,\n\n\n\n\n\n\nAs in \nscuff-neq\n, you can request either \n(a)\n frequency-resolved\ninformation on heat-transfer rates and NEQ Casimir forces (in which case \nyou will specify a list of frequencies and will get back a list of \nfrequency-specific values of energy and momentum fluxes) or \n\n(b)\n frequency-integrated information, in which case you will assign \ntemperatures to each body in your geometry and \nbuff-neq\n will \nnumerically integrate the fluxes, weighted by appropriate Bose-Einstein \nfactors, to obtain the total heat-transfer rate or NEQ Casimir force. \n(For more details, see \n\nWhat \nbuff-neq\n actually computes\n.)\n\n\n\n\n\n\nAs in \nscuff-neq\n, you can specify an optional list of \n\ngeometrical transformations\n\ndescribing various displacements and rotations of the bodies \nin your geometry; in this case you will get back values of the \nfrequency-resolved or frequency-integrated quantities for each \ntransformation you specify.\n\n\n\n\n\n\nFor Casimir forces and torques, the quantities computed by \n\nbuff-neq\n are only the \nnon-equilibrium\n contributions to \nthe total force and torque---that\nis, the contributions arising from the temperature \ndifferences between individual bodies and the surrounding environment.\nTo get the total force, these must be added to the \nequilibrium\n\ncontributions, which are the Casimir forces and torques for the \ncase in which all bodies are at the temperature of the environment.\n(For heat-transfer rates there is of course no equilibrium \ncontribution, as there is no net power transfer between \nbodies at thermal equilibrium.)\n\n\nTable of Contents\n\n\n1. What \nbuff-neq\n actually computes\n\n\n2. \nbuff-neq\n command-line options\n\n\nCommon options\n\n\nOptions requesting output quantities\n\n\nOptions specifying object temperatures\n\n\nOptions controlling the computation of power, force, and torque\n\n\n\n\n\n\n3. Examples of calculations using \nbuff-neq\n\n\n\n\n\n\n1. What \nbuff-neq\n actually computes\n\n\nbuff-neq\n implements the FVC approach to non-equilibrium \nfluctuation phenomena.  This is an algorithm for computing the \nthermal averages of power, force, and torque (PFT) quantities \nin geometries consisting of compact material bodies at various \ntemperatures embedded in an finite-temperature or \nzero-temperature environment.\n\n\n\n\n2. \nbuff-neq\n command-line options\n\n\nCommon options\n\n\nbuff-neq\n recognizes the following subset of the\nlist of commonly accepted options to \nbuff-em\n command-line codes;\nthese all have the same meaning as\nthe \ncorresponding options in \nscuff-em\n. \n(In general, almost everything mentioned in the \n\nGeneral reference for \nscuff-em\n command-line applications\n \npertains to \nbuff-em\n command-line applications as well.)\n\n\n--geometry\n--TransFile\n--Omega\n--OmegaFile\n--OmegaQuadrature\n--OmegaMin\n--AbsTol\n--RelTol\n--FileBase\n\n\nOptions requesting output quantities\n\n\n--PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque\n\n\n\n\nSpecifies the quantities in which you are interested:\nabsorbed power (\n--PAbs\n), radiated power (\n--PRad\n),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the\n\n.log\n file\n to see how \nmuch\n additional time each\nextra output quantity takes to compute).\n\n\n\n\nOptions specifying object temperatures\n\n\n--Temperature     UpperSphere 300\n--Temperature     LowerSphere 100\n\n\n--TEnvironment    100\n\n\n--TemperatureFile MyTemperatureFile.SVTensor\n\n\n\n\nThe first two options here set the temperatures\nof the objects labeled \nUpperSphere\n and\n\nLowerSphere\n in the \n.buffgeo\n file. \n\nTemperature specifications are interpreted in \nunits of Kelvin\n, so \n300\n corresponds to \nroom temperature.\n\n\nThe \n--TEnvironment\n option here sets the temperature of\nthe environment in which the objects are embedded.\n\n\nThe \n--TemperatureFile\n option here may be used to\ndefine spatially inhomogeneous temperature profiles.\nIn this case, \nMyTemperatureFile.SVTensor\n should be\na \n.SVTensor\n file\n describing an isotropic\nbut possibly spatially inhomogeneous tensor \n\n\\mathbf{Q}(\\mathbf x)=Q(\\mathbf x)\\mathbf{1}\n\nwhose scalar value is the temperature in Kelvin; for example,\n\nMyTemperatureFile.SVTensor\n might contain the line\n\n\nbash\n  Q = 300*z + 100*(1-z)\n    \n\n\nThis describes a temperature profile that varies linearly\nfrom 100 Kelvin at \nz\n=0 to 300 Kelvin at \nz\n=1. (Here\n\nQ\n is just the conventional name used in the \n\n.SVTensor\n file specification\n for assigning\nformulas for tensor components.)\n\n\nNote that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the \n--omega\n or \n--omegaFile\n\noption) and you do not specify any \n--temperature\n \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.\n\n\n\n\nOptions controlling the computation of power, force, and torque\n\n\nbuff-neq\n implements several algorithms for computing\npowers, forces, and torques (PFTs). You may request the computation\nof PFTs via more than one method.\n\n\n--JDEPFT\n\n\n\n\nRequests that PFTs be computed using the \n\\mathbf{J} \\cdot \\mathbf{E}\n method.\n\n\n\n\n--MomentPFT\n\n\n\n\nRequests that PFTs be computed using the moment method.\n\n\n\n\n--DSIPoints  302\n--DSIMesh BoundingMesh.msh\n\n\n--DSIPoints2 590\n\n\n--DSIRadius  5.0\n\n\n\n\nThese options request PFT calculations via the displaced-surface-integral\n(DSI) method.\n\n\nTo request a DSIPFT calculation using \nN\n cubature points\na over a bounding sphere of radius \nR,\n say\n\n--DSIPoints N --DSIRadius R\n. To see the allowed values\nof \nN\n, type \nbuff-neq --help.\n\n\nAlternatively, you can say \n--DSIMesh BoundingMesh.msh\n\nto request a DSIPFT calculation using \na one-point cubature over each triangular panel of \n\nBoundingMesh.msh\n.\n\n\nTo get a \"second opinion,\" you can request a second \nDSIPFT calculation by saying \n--DSIPoints2 N\n.\nThis will perform a DSIPFT calculation over\nbounding sphere with \nN\n points (with the sphere radius\nset by \n--DSIRadius\n). This calculation will be \nperformed in addition to the first DSIPFT calculation\nyou requested by specifying \n--DSIPoints\n or \n\n--DSIMesh.\n\n\n\n\n\n\n\n\n3. Examples of calculations using \nbuff-neq\n\n\n\n\nThermal radiation and self-propulsion of photon torpedoes\n\n\nThermal self-rotation of QED pinwheels", 
            "title": "buff-neq"
        }, 
        {
            "location": "/applications/buff-neq/#2-buff-neq-command-line-options", 
            "text": "Common options  buff-neq  recognizes the following subset of the\nlist of commonly accepted options to  buff-em  command-line codes;\nthese all have the same meaning as\nthe  corresponding options in  scuff-em . \n(In general, almost everything mentioned in the  General reference for  scuff-em  command-line applications  \npertains to  buff-em  command-line applications as well.)  --geometry\n--TransFile\n--Omega\n--OmegaFile\n--OmegaQuadrature\n--OmegaMin\n--AbsTol\n--RelTol\n--FileBase  Options requesting output quantities  --PAbs  \n--PRad  \n--XForce  \n--YForce  \n--ZForce\n--XTorque  \n--YTorque\n--ZTorque   Specifies the quantities in which you are interested:\nabsorbed power ( --PAbs ), radiated power ( --PRad ),\nCartesian force components, or Cartesian torque components.\nYou may specify none, all, or any subset of these options,\nbut each option you specify will generally increase\nthe computation time (you can scrutinize the .log  file  to see how  much  additional time each\nextra output quantity takes to compute).   Options specifying object temperatures  --Temperature     UpperSphere 300\n--Temperature     LowerSphere 100  --TEnvironment    100  --TemperatureFile MyTemperatureFile.SVTensor   The first two options here set the temperatures\nof the objects labeled  UpperSphere  and LowerSphere  in the  .buffgeo  file.  Temperature specifications are interpreted in \nunits of Kelvin , so  300  corresponds to \nroom temperature.  The  --TEnvironment  option here sets the temperature of\nthe environment in which the objects are embedded.  The  --TemperatureFile  option here may be used to\ndefine spatially inhomogeneous temperature profiles.\nIn this case,  MyTemperatureFile.SVTensor  should be\na  .SVTensor  file  describing an isotropic\nbut possibly spatially inhomogeneous tensor  \\mathbf{Q}(\\mathbf x)=Q(\\mathbf x)\\mathbf{1} \nwhose scalar value is the temperature in Kelvin; for example, MyTemperatureFile.SVTensor  might contain the line  bash\n  Q = 300*z + 100*(1-z)       This describes a temperature profile that varies linearly\nfrom 100 Kelvin at  z =0 to 300 Kelvin at  z =1. (Here Q  is just the conventional name used in the  .SVTensor  file specification  for assigning\nformulas for tensor components.)  Note that the temperatures of all objects, and of\nthe environment, are zero by default. This means that,\nif you request a full frequency-integrated calculation\n(which you do by omitting the  --omega  or  --omegaFile \noption) and you do not specify any  --temperature  \noptions, the code will chug for a while (computing \ntemperature-independent fluxes at various frequencies)\nbefore reporting strictly zero values for all\nquantities! This is probably not what you want.   Options controlling the computation of power, force, and torque  buff-neq  implements several algorithms for computing\npowers, forces, and torques (PFTs). You may request the computation\nof PFTs via more than one method.  --JDEPFT   Requests that PFTs be computed using the  \\mathbf{J} \\cdot \\mathbf{E}  method.   --MomentPFT   Requests that PFTs be computed using the moment method.   --DSIPoints  302\n--DSIMesh BoundingMesh.msh  --DSIPoints2 590  --DSIRadius  5.0   These options request PFT calculations via the displaced-surface-integral\n(DSI) method.  To request a DSIPFT calculation using  N  cubature points\na over a bounding sphere of radius  R,  say --DSIPoints N --DSIRadius R . To see the allowed values\nof  N , type  buff-neq --help.  Alternatively, you can say  --DSIMesh BoundingMesh.msh \nto request a DSIPFT calculation using \na one-point cubature over each triangular panel of  BoundingMesh.msh .  To get a \"second opinion,\" you can request a second \nDSIPFT calculation by saying  --DSIPoints2 N .\nThis will perform a DSIPFT calculation over\nbounding sphere with  N  points (with the sphere radius\nset by  --DSIRadius ). This calculation will be \nperformed in addition to the first DSIPFT calculation\nyou requested by specifying  --DSIPoints  or  --DSIMesh.", 
            "title": "2. buff-neq command-line options"
        }, 
        {
            "location": "/applications/buff-neq/#3-examples-of-calculations-using-buff-neq", 
            "text": "Thermal radiation and self-propulsion of photon torpedoes  Thermal self-rotation of QED pinwheels", 
            "title": "3. Examples of calculations using buff-neq"
        }, 
        {
            "location": "/applications/buff-analyze/", 
            "text": "Analyzing objects and geometries with \nbuff-analyze\n\n\n\nThe \nbuff-em\n suite comes with a simple standalone utility named \n\nbuff-analyze\n that you can use to gather some quick statistics on\nmeshed objects and scattering geometries described by mesh files and \ngeometry files.\n\n\nThere are several situations in which this can be useful:\n\n\n\n\nYou want to know how much memory will be occupied by the VIE matrix \n    for a geometry described by a \n.buffgeo\n file.\n\n\nYour \n.buffgeo\n file contains multiple \nOBJECTs\n, each \n    described by separate volume meshes and possibly displaced\n    and/or rotated, and you want to visualize the full geometry to \n    make sure the file you wrote actually describes what you want.\n\n\nYou have created a \n.trans\n file describing a list of \n    \ngeometrical transformations\n\n    to be applied to your geometry, and before running a full calculation \n    you want to do a quick sanity check by visualizing the geometry under\n    each of your transformations to make sure they are what you intended.\n\n\nYour geometry involves one or more \n    \nspatially inhomogeneous permittivities\n,\n    and you want a plot of permittivity vs. space to double-check that \n    the permittivity you got is the one you wanted.\n\n\nYou have created a new volume mesh and you want to do a \n    preliminary calculation to compute the \n    \nbuff-em\n cache\n\n    before you start any actual calculations.\n\n\n\n\nTable of Contents\n\n\nbuff-analyze Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\nOption specifying a list of geometrical transformations\n\n\nOptions controlling the generation of visualization files\n\n\nOptions controlling the generation of cache files\n\n\n\n\n\n\nbuff-analyze console output\n\n\nRunning buff-analyze on a geometry file\n\n\n\n\n\n\nRunning buff-analyze to precompute the buff-em cache\n\n\n\n\n\n\n\n\nbuff-analyze\n Command-Line Options\n\n\nOptions specifying the file to analyze\n\n\n--geometry MyGeometry.buffgeo\n\n\nAnalyze a full geometry described by a\n\nbuff-em geometry.\n\n\n--mesh     MyObject.vmsh\n\n\n--meshFile MyObject.vmsh\n\n\nAnalyze a single object described by a volume mesh. (The\ntwo options are synonymous.)\n\n\nOption specifying a list of geometrical transformations\n\n\n--TransFile MyTransFile.trans\n\n\nSpecify a list of \n\ngeometrical transformations\n\nto be applied to a geometry. This is useful for \n(a)\n checking\nthat your transformation file can be properly parsed by \n\nbuff-em\n, and \n(b)\n producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.\n\n\nOptions controlling the generation of visualization files\n\n\n--WriteGMSHFiles\n\n\nAppend visualization data to \ngmsh\n visualization files that \nprovides information on how the geometry is represented internally \nwithin \nbuff-em\n. \n\n\n--PlotPermittivity\n\n\nProduces a visualization file showing the spatial variation\nof the dielectric permittivity in your geometry. This is useful\nif you specified any \n.SVTensor\n files and want to doublecheck\nthat your specification was interpreted correctly by \nbuff-em\n.\n\n\nOptions controlling the generation of cache files\n\n\n--WriteCache\n\n\n\n\nbuff-analyze\n console output\n\n\nRunning \nbuff-analyze\n on a geometry file\n\n\nRunning \nbuff-analyze\n on a typical \nbuff-em\n geometry file \nyields console output that looks like this:\n\n\n% buff-analyze --geometry ThinPinwheel_N7_2190.buffgeo\n\n*\n* Geometry file MESH__ThinPinwheel_N7_2190__MAT__Gold.buffgeo: 1 objects \n*\n\n**************************************************\n* Object 0: \n**************************************************\nVolume ThinPinwheel_N7_2190 (file ThinPinwheel_N7_2190.vmsh): \n 878 vertices \n 2190 tetrahedra \n 3568 interior faces \n 1624 exterior faces \n\n Volume:          8.682680e-01 \n Surface area:    1.479837e+01 \n\n Moment of inertia: {+8.91e-01,+8.91e-01,+1.78e+00}\n\n Min/Max/Avg Quality factor: 1.376158e-01 / 9.928907e-01 / 7.479818e-01 \n\nThank you for your support.\n\n\n\n\n\n\nRunning \nbuff-analyze\n to precompute the \nbuff-em\n cache\n\n\nAs discussed \nhere\n,\nthe first calculation performed by \nbuff-em\n on a given\nvolume mesh is considerably slower than all subsequent \ncalculations, because on this first calculation the code \ncomputes and certain frequency- and material-independent \nquantities needed to assemble the system matrix, which \nit then writes to a binary data file named \nMesh.cache\n\n(where \nMesh.vmsh\n is the name of the mesh file as \nspecified using the\n\nMESHFILE\n keyword in a \n.buffgeo\n file\n).\nIn some case it is convenient to generate the \n.cache\n\nfile before running any actual scattering or \nnon-equilibrium Casimir calculations. (For example,\nif you are planning to launch a bunch of parallel \n\nbuff-em\n jobs that will refer to the same \n.vmsh\n \nfiles---even if the corresponding objects have \ndifferent material properties!---you will want to \nprecompute the \n.cache\n file so that the jobs don't\nall repeat the same calculation when they start up).\n\n\nYou can use \nbuff-analyze\n to precompute the cache\nfile for a given volume mesh like this:\n\n\n % buff-analyze --mesh MyObject.vmsh --WriteCache\n\n\n\n\nThis will produce a file named \nMyObject.cache\n.\nIf the environment variable \nBUFF_CACHE_DIR\n is \nset, then this file will be written to the\ndirectory it specifies; otherwise, the file will\nbe written to the current working directory.\n\n\nThen all subsequent calculations that\nrefer to \nMyObject.vmsh\n (including calculations\nperformed by \nbuff-scatter\n, \nbuff-neq\n, or\nAPI codes) will automatically read in the\n\nMyObject.cache\n file (assuming they can find\nit either in their current working directory\nor in the directory specified by \nBUFF_CACHE_DIR\n),\nthus bypassing the costly cache-computation\nstep and significantly accelerating calculations.", 
            "title": "buff-analyze"
        }, 
        {
            "location": "/applications/buff-analyze/#options-specifying-the-file-to-analyze", 
            "text": "--geometry MyGeometry.buffgeo  Analyze a full geometry described by a buff-em geometry.  --mesh     MyObject.vmsh  --meshFile MyObject.vmsh  Analyze a single object described by a volume mesh. (The\ntwo options are synonymous.)", 
            "title": "Options specifying the file to analyze"
        }, 
        {
            "location": "/applications/buff-analyze/#option-specifying-a-list-of-geometrical-transformations", 
            "text": "--TransFile MyTransFile.trans  Specify a list of  geometrical transformations \nto be applied to a geometry. This is useful for  (a)  checking\nthat your transformation file can be properly parsed by  buff-em , and  (b)  producing a visualization output file to \nconfirm that the transformations you got are the ones you wanted.", 
            "title": "Option specifying a list of geometrical transformations"
        }, 
        {
            "location": "/applications/buff-analyze/#options-controlling-the-generation-of-visualization-files", 
            "text": "--WriteGMSHFiles  Append visualization data to  gmsh  visualization files that \nprovides information on how the geometry is represented internally \nwithin  buff-em .   --PlotPermittivity  Produces a visualization file showing the spatial variation\nof the dielectric permittivity in your geometry. This is useful\nif you specified any  .SVTensor  files and want to doublecheck\nthat your specification was interpreted correctly by  buff-em .", 
            "title": "Options controlling the generation of visualization files"
        }, 
        {
            "location": "/applications/buff-analyze/#options-controlling-the-generation-of-cache-files", 
            "text": "--WriteCache", 
            "title": "Options controlling the generation of cache files"
        }, 
        {
            "location": "/applications/buff-analyze/#buff-analyze-console-output", 
            "text": "Running  buff-analyze  on a geometry file  Running  buff-analyze  on a typical  buff-em  geometry file \nyields console output that looks like this:  % buff-analyze --geometry ThinPinwheel_N7_2190.buffgeo\n\n*\n* Geometry file MESH__ThinPinwheel_N7_2190__MAT__Gold.buffgeo: 1 objects \n*\n\n**************************************************\n* Object 0: \n**************************************************\nVolume ThinPinwheel_N7_2190 (file ThinPinwheel_N7_2190.vmsh): \n 878 vertices \n 2190 tetrahedra \n 3568 interior faces \n 1624 exterior faces \n\n Volume:          8.682680e-01 \n Surface area:    1.479837e+01 \n\n Moment of inertia: {+8.91e-01,+8.91e-01,+1.78e+00}\n\n Min/Max/Avg Quality factor: 1.376158e-01 / 9.928907e-01 / 7.479818e-01 \n\nThank you for your support.", 
            "title": "buff-analyze console output"
        }, 
        {
            "location": "/applications/buff-analyze/#running-buff-analyze-to-precompute-the-buff-em-cache", 
            "text": "As discussed  here ,\nthe first calculation performed by  buff-em  on a given\nvolume mesh is considerably slower than all subsequent \ncalculations, because on this first calculation the code \ncomputes and certain frequency- and material-independent \nquantities needed to assemble the system matrix, which \nit then writes to a binary data file named  Mesh.cache \n(where  Mesh.vmsh  is the name of the mesh file as \nspecified using the MESHFILE  keyword in a  .buffgeo  file ).\nIn some case it is convenient to generate the  .cache \nfile before running any actual scattering or \nnon-equilibrium Casimir calculations. (For example,\nif you are planning to launch a bunch of parallel  buff-em  jobs that will refer to the same  .vmsh  \nfiles---even if the corresponding objects have \ndifferent material properties!---you will want to \nprecompute the  .cache  file so that the jobs don't\nall repeat the same calculation when they start up).  You can use  buff-analyze  to precompute the cache\nfile for a given volume mesh like this:   % buff-analyze --mesh MyObject.vmsh --WriteCache  This will produce a file named  MyObject.cache .\nIf the environment variable  BUFF_CACHE_DIR  is \nset, then this file will be written to the\ndirectory it specifies; otherwise, the file will\nbe written to the current working directory.  Then all subsequent calculations that\nrefer to  MyObject.vmsh  (including calculations\nperformed by  buff-scatter ,  buff-neq , or\nAPI codes) will automatically read in the MyObject.cache  file (assuming they can find\nit either in their current working directory\nor in the directory specified by  BUFF_CACHE_DIR ),\nthus bypassing the costly cache-computation\nstep and significantly accelerating calculations.", 
            "title": "Running buff-analyze to precompute the buff-em cache"
        }, 
        {
            "location": "/API/libbuff/", 
            "text": "buff-em\n core library documentation\n\n\n\n\nThe \nbuff-em\n core library, \nlibbuff\n, exports a C++ class named \n\nSWGGeometry.\n The public methods of this class offer access to the \ncomputational routines provided by \nbuff-em\n to implement the \ndiscretized volume-integral-equation (VIE) approach to \ncomputational electromagnetism.\n\n\nThe \nSWGGeometry\n class is analogous to the \nRWGGeometry\n class in \nthe \nscuff-em\n core library\n\n\nCreating an SWGGeometry\n\n\n  SWGGeometry *G = new SWGGeometry(\nE10Sphere_533.buffgeo\n);\n\n\n\n\nSetting up and solving the VIE system\n\n\nNote: Incident fields are handled the same way as in \nscuff-em\n; see\n\nIncident fields in \nscuff-em\n.\n\n\n  HMatrix *M     = G-\nAllocateVIEMatrix();\n  HVector *J     = G-\nAllocateRHSVector();\n\n  cdouble E0[3]  = {1.0, 0.0, 0.0};\n  double nHat[3] = {0.0, 0.0, 1.0};\n  PlaneWave *PW  = new PlaneWave(E0, nHat);\n\n  G-\nAssembleVIEMatrix(Omega, M);\n  G-\nAssembleRHSVector(Omega, PW, J);\n  M-\nLUFactorize();\n  M-\nLUSolve(J);\n\n\n\n\nComputing scattered and total fields\n\n\n\n  HMatrix *XMatrix=new HMatrix(\nListOfEvaluationPoints\n);\n\n  HMatrix *EHIncMatrix = G-\nGetFields(PW,  J, Omega, XMatrix);\n  HMatrix *EHScatMatrix = G-\nGetFields(0,  J, Omega, XMatrix);\n\n  // E, H fields at the nth evaluation point are now in the \n  // nth row of the matrices, like this: Ex Ey Ez Hx Hy Hz\n\n  int np=7;\n  double X[3];\n  cdouble E[3], H[3];\n\n  XMatrix-\nGetEntries(np, \n:\n, X);\n  E[0] = EHIncMatrix-\nGetEntry(np, 0) + EHScatMatrix-\nGetEntry(np, 0);\n  E[1] = EHIncMatrix-\nGetEntry(np, 1) + EHScatMatrix-\nGetEntry(np, 1);\n  E[2] = EHIncMatrix-\nGetEntry(np, 2) + EHScatMatrix-\nGetEntry(np, 2);\n  H[0] = EHIncMatrix-\nGetEntry(np, 3) + EHScatMatrix-\nGetEntry(np, 3);\n  H[1] = EHIncMatrix-\nGetEntry(np, 4) + EHScatMatrix-\nGetEntry(np, 4);\n  H[2] = EHIncMatrix-\nGetEntry(np, 5) + EHScatMatrix-\nGetEntry(np, 5);\n\n  // now X[0..2] are the coordinates of evaluation point #np\n  // and E[0..2], H[0..2] are the total E and H fields there\n\n\n\n\nTransforming the geometry\n\n\nTo rotate the object named \"SmallerTorus\" by 90 degrees around the \nz\n\naxis, then displaced it upward by 3 length units:\n\n\n SWGVolume *O = G-\nGetObjectByLabel(\nSmallerTorus\n);\n if (!O) \n  ErrExit(\nno such object\n); \n\n O-\nTransform(\nROTATED 90 ABOUT 0 0 1\n);\n O-\nTransform(\nDISPLACED 0 0 3\n);\n\n\n\n\nComputing power, force, and torque\n\n\n PFTOptions MyOptions;\n InitPFTOptions(\nMyOptions);\n\n PFTOptions-\nPFTMethod = BUFF_PFT_JDE; // or BUFF_PFT_DSI or BUFF_PFT_OVERLAP\n PFTOptions-\nIF = PW; // incident field is needed for some PFT methods\n\n HMatrix *PFTMatrix=G-\nGetPFT(J, Omega);\n\n // PFTMatrix-\nGetEntryD(no, nq) now returns the #nqth power quantity for object #no\n // no=0,1, ..., G-\nNumObjects - 1\n // nq=0,1   for absorbed, scattered power\n //    2,3,4 for force (x,y,z)\n //    5,6,7 for torque (x,y,z)", 
            "title": "libbuff"
        }, 
        {
            "location": "/API/libbuff/#setting-up-and-solving-the-vie-system", 
            "text": "Note: Incident fields are handled the same way as in  scuff-em ; see Incident fields in  scuff-em .    HMatrix *M     = G- AllocateVIEMatrix();\n  HVector *J     = G- AllocateRHSVector();\n\n  cdouble E0[3]  = {1.0, 0.0, 0.0};\n  double nHat[3] = {0.0, 0.0, 1.0};\n  PlaneWave *PW  = new PlaneWave(E0, nHat);\n\n  G- AssembleVIEMatrix(Omega, M);\n  G- AssembleRHSVector(Omega, PW, J);\n  M- LUFactorize();\n  M- LUSolve(J);", 
            "title": "Setting up and solving the VIE system"
        }, 
        {
            "location": "/API/libbuff/#computing-scattered-and-total-fields", 
            "text": "HMatrix *XMatrix=new HMatrix( ListOfEvaluationPoints );\n\n  HMatrix *EHIncMatrix = G- GetFields(PW,  J, Omega, XMatrix);\n  HMatrix *EHScatMatrix = G- GetFields(0,  J, Omega, XMatrix);\n\n  // E, H fields at the nth evaluation point are now in the \n  // nth row of the matrices, like this: Ex Ey Ez Hx Hy Hz\n\n  int np=7;\n  double X[3];\n  cdouble E[3], H[3];\n\n  XMatrix- GetEntries(np,  : , X);\n  E[0] = EHIncMatrix- GetEntry(np, 0) + EHScatMatrix- GetEntry(np, 0);\n  E[1] = EHIncMatrix- GetEntry(np, 1) + EHScatMatrix- GetEntry(np, 1);\n  E[2] = EHIncMatrix- GetEntry(np, 2) + EHScatMatrix- GetEntry(np, 2);\n  H[0] = EHIncMatrix- GetEntry(np, 3) + EHScatMatrix- GetEntry(np, 3);\n  H[1] = EHIncMatrix- GetEntry(np, 4) + EHScatMatrix- GetEntry(np, 4);\n  H[2] = EHIncMatrix- GetEntry(np, 5) + EHScatMatrix- GetEntry(np, 5);\n\n  // now X[0..2] are the coordinates of evaluation point #np\n  // and E[0..2], H[0..2] are the total E and H fields there", 
            "title": "Computing scattered and total fields"
        }, 
        {
            "location": "/API/libbuff/#transforming-the-geometry", 
            "text": "To rotate the object named \"SmallerTorus\" by 90 degrees around the  z \naxis, then displaced it upward by 3 length units:   SWGVolume *O = G- GetObjectByLabel( SmallerTorus );\n if (!O) \n  ErrExit( no such object ); \n\n O- Transform( ROTATED 90 ABOUT 0 0 1 );\n O- Transform( DISPLACED 0 0 3 );", 
            "title": "Transforming the geometry"
        }, 
        {
            "location": "/API/libbuff/#computing-power-force-and-torque", 
            "text": "PFTOptions MyOptions;\n InitPFTOptions( MyOptions);\n\n PFTOptions- PFTMethod = BUFF_PFT_JDE; // or BUFF_PFT_DSI or BUFF_PFT_OVERLAP\n PFTOptions- IF = PW; // incident field is needed for some PFT methods\n\n HMatrix *PFTMatrix=G- GetPFT(J, Omega);\n\n // PFTMatrix- GetEntryD(no, nq) now returns the #nqth power quantity for object #no\n // no=0,1, ..., G- NumObjects - 1\n // nq=0,1   for absorbed, scattered power\n //    2,3,4 for force (x,y,z)\n //    5,6,7 for torque (x,y,z)", 
            "title": "Computing power, force, and torque"
        }, 
        {
            "location": "/tex/buff-em-tex/", 
            "text": "buff-em\n technical memo\n\n\nHere's a technical memo discussing some aspects of \nbuff-em\n:\n\nbuff-em.pdf", 
            "title": "Technical memo"
        }
    ]
}